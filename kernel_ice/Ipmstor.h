// **********************************************************************
//
// Copyright (c) 2003-2013 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.5.0
//
// <auto-generated>
//
// Generated from file `Ipmstor.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __Ipmstor_h__
#define __Ipmstor_h__

#include <Ice/ProxyF.h>
#include <Ice/ObjectF.h>
#include <Ice/Exception.h>
#include <Ice/LocalObject.h>
#include <Ice/StreamHelpers.h>
#include <Ice/Proxy.h>
#include <Ice/Object.h>
#include <Ice/Outgoing.h>
#include <Ice/OutgoingAsync.h>
#include <Ice/Incoming.h>
#include <Ice/Direct.h>
#include <Ice/FactoryTableInit.h>
#include <IceUtil/ScopedArray.h>
#include <IceUtil/Optional.h>
#include <Ice/StreamF.h>
#include <Ice/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 305
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 > 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 0
#       error Ice patch level mismatch!
#   endif
#endif

namespace IceProxy
{

namespace IPMS
{

namespace jk
{

class Ipmstor;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::IPMS::jk::Ipmstor>&);
::IceProxy::Ice::Object* upCast(::IceProxy::IPMS::jk::Ipmstor*);

}

}

}

namespace IPMS
{

namespace jk
{

class Ipmstor;
bool operator==(const Ipmstor&, const Ipmstor&);
bool operator<(const Ipmstor&, const Ipmstor&);
::Ice::Object* upCast(::IPMS::jk::Ipmstor*);
typedef ::IceInternal::Handle< ::IPMS::jk::Ipmstor> IpmstorPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::IPMS::jk::Ipmstor> IpmstorPrx;
void __patch(IpmstorPtr&, const ::Ice::ObjectPtr&);

}

}

namespace IPMS
{

namespace yc
{

class IPUploadError : public ::Ice::UserException
{
public:

    IPUploadError() {}
    virtual ~IPUploadError() throw();

    virtual ::std::string ice_name() const;
    virtual IPUploadError* ice_clone() const;
    virtual void ice_throw() const;

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::UserException::__writeImpl;
    using ::Ice::UserException::__readImpl;
    #endif
};

static IPUploadError __IPUploadError_init;

class IPDataTooLargerError : public ::Ice::UserException
{
public:

    IPDataTooLargerError() {}
    virtual ~IPDataTooLargerError() throw();

    virtual ::std::string ice_name() const;
    virtual IPDataTooLargerError* ice_clone() const;
    virtual void ice_throw() const;

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::UserException::__writeImpl;
    using ::Ice::UserException::__readImpl;
    #endif
};

class IPDownloadError : public ::Ice::UserException
{
public:

    IPDownloadError() {}
    virtual ~IPDownloadError() throw();

    virtual ::std::string ice_name() const;
    virtual IPDownloadError* ice_clone() const;
    virtual void ice_throw() const;

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::UserException::__writeImpl;
    using ::Ice::UserException::__readImpl;
    #endif
};

}

namespace dx
{

struct IPhebing
{
    ::std::string start;
    ::std::string end;
    ::std::string provid;
    ::std::string cityid;

    bool operator==(const IPhebing& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(start != __rhs.start)
        {
            return false;
        }
        if(end != __rhs.end)
        {
            return false;
        }
        if(provid != __rhs.provid)
        {
            return false;
        }
        if(cityid != __rhs.cityid)
        {
            return false;
        }
        return true;
    }

    bool operator<(const IPhebing& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(start < __rhs.start)
        {
            return true;
        }
        else if(__rhs.start < start)
        {
            return false;
        }
        if(end < __rhs.end)
        {
            return true;
        }
        else if(__rhs.end < end)
        {
            return false;
        }
        if(provid < __rhs.provid)
        {
            return true;
        }
        else if(__rhs.provid < provid)
        {
            return false;
        }
        if(cityid < __rhs.cityid)
        {
            return true;
        }
        else if(__rhs.cityid < cityid)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const IPhebing& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const IPhebing& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const IPhebing& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const IPhebing& __rhs) const
    {
        return !operator<(__rhs);
    }
};

struct AREAinfo
{
    ::std::string areapy;
    ::std::string areaname;

    bool operator==(const AREAinfo& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(areapy != __rhs.areapy)
        {
            return false;
        }
        if(areaname != __rhs.areaname)
        {
            return false;
        }
        return true;
    }

    bool operator<(const AREAinfo& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(areapy < __rhs.areapy)
        {
            return true;
        }
        else if(__rhs.areapy < areapy)
        {
            return false;
        }
        if(areaname < __rhs.areaname)
        {
            return true;
        }
        else if(__rhs.areaname < areaname)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const AREAinfo& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const AREAinfo& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const AREAinfo& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const AREAinfo& __rhs) const
    {
        return !operator<(__rhs);
    }
};

struct SSIsp
{
    ::std::string shengpy;
    ::std::string shipy;
    ::std::string isppy;

    bool operator==(const SSIsp& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(shengpy != __rhs.shengpy)
        {
            return false;
        }
        if(shipy != __rhs.shipy)
        {
            return false;
        }
        if(isppy != __rhs.isppy)
        {
            return false;
        }
        return true;
    }

    bool operator<(const SSIsp& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(shengpy < __rhs.shengpy)
        {
            return true;
        }
        else if(__rhs.shengpy < shengpy)
        {
            return false;
        }
        if(shipy < __rhs.shipy)
        {
            return true;
        }
        else if(__rhs.shipy < shipy)
        {
            return false;
        }
        if(isppy < __rhs.isppy)
        {
            return true;
        }
        else if(__rhs.isppy < isppy)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const SSIsp& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const SSIsp& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const SSIsp& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const SSIsp& __rhs) const
    {
        return !operator<(__rhs);
    }
};

struct VIEWinfo
{
    ::std::string viewname;
    ::Ice::Int viewareaid;
    ::Ice::Int viewispid;
    ::std::string viewpci;

    bool operator==(const VIEWinfo& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(viewname != __rhs.viewname)
        {
            return false;
        }
        if(viewareaid != __rhs.viewareaid)
        {
            return false;
        }
        if(viewispid != __rhs.viewispid)
        {
            return false;
        }
        if(viewpci != __rhs.viewpci)
        {
            return false;
        }
        return true;
    }

    bool operator<(const VIEWinfo& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(viewname < __rhs.viewname)
        {
            return true;
        }
        else if(__rhs.viewname < viewname)
        {
            return false;
        }
        if(viewareaid < __rhs.viewareaid)
        {
            return true;
        }
        else if(__rhs.viewareaid < viewareaid)
        {
            return false;
        }
        if(viewispid < __rhs.viewispid)
        {
            return true;
        }
        else if(__rhs.viewispid < viewispid)
        {
            return false;
        }
        if(viewpci < __rhs.viewpci)
        {
            return true;
        }
        else if(__rhs.viewpci < viewpci)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const VIEWinfo& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const VIEWinfo& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const VIEWinfo& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const VIEWinfo& __rhs) const
    {
        return !operator<(__rhs);
    }
};

struct IPpart
{
    ::std::string ipparts;
    ::std::string startip;
    ::std::string start;
    ::std::string end;
    ::std::string endip;

    bool operator==(const IPpart& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(ipparts != __rhs.ipparts)
        {
            return false;
        }
        if(startip != __rhs.startip)
        {
            return false;
        }
        if(start != __rhs.start)
        {
            return false;
        }
        if(end != __rhs.end)
        {
            return false;
        }
        if(endip != __rhs.endip)
        {
            return false;
        }
        return true;
    }

    bool operator<(const IPpart& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(ipparts < __rhs.ipparts)
        {
            return true;
        }
        else if(__rhs.ipparts < ipparts)
        {
            return false;
        }
        if(startip < __rhs.startip)
        {
            return true;
        }
        else if(__rhs.startip < startip)
        {
            return false;
        }
        if(start < __rhs.start)
        {
            return true;
        }
        else if(__rhs.start < start)
        {
            return false;
        }
        if(end < __rhs.end)
        {
            return true;
        }
        else if(__rhs.end < end)
        {
            return false;
        }
        if(endip < __rhs.endip)
        {
            return true;
        }
        else if(__rhs.endip < endip)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const IPpart& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const IPpart& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const IPpart& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const IPpart& __rhs) const
    {
        return !operator<(__rhs);
    }
};

struct PRinfo
{
    ::std::string provname;
    ::std::string provpy;

    bool operator==(const PRinfo& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(provname != __rhs.provname)
        {
            return false;
        }
        if(provpy != __rhs.provpy)
        {
            return false;
        }
        return true;
    }

    bool operator<(const PRinfo& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(provname < __rhs.provname)
        {
            return true;
        }
        else if(__rhs.provname < provname)
        {
            return false;
        }
        if(provpy < __rhs.provpy)
        {
            return true;
        }
        else if(__rhs.provpy < provpy)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const PRinfo& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const PRinfo& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const PRinfo& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const PRinfo& __rhs) const
    {
        return !operator<(__rhs);
    }
};

struct SSinfo
{
    ::std::string provname;
    ::std::string provpy;
    ::std::string cityname;
    ::std::string citypy;

    bool operator==(const SSinfo& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(provname != __rhs.provname)
        {
            return false;
        }
        if(provpy != __rhs.provpy)
        {
            return false;
        }
        if(cityname != __rhs.cityname)
        {
            return false;
        }
        if(citypy != __rhs.citypy)
        {
            return false;
        }
        return true;
    }

    bool operator<(const SSinfo& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(provname < __rhs.provname)
        {
            return true;
        }
        else if(__rhs.provname < provname)
        {
            return false;
        }
        if(provpy < __rhs.provpy)
        {
            return true;
        }
        else if(__rhs.provpy < provpy)
        {
            return false;
        }
        if(cityname < __rhs.cityname)
        {
            return true;
        }
        else if(__rhs.cityname < cityname)
        {
            return false;
        }
        if(citypy < __rhs.citypy)
        {
            return true;
        }
        else if(__rhs.citypy < citypy)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const SSinfo& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const SSinfo& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const SSinfo& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const SSinfo& __rhs) const
    {
        return !operator<(__rhs);
    }
};

struct ISPinfo
{
    ::std::string ispname;
    ::std::string isppy;

    bool operator==(const ISPinfo& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(ispname != __rhs.ispname)
        {
            return false;
        }
        if(isppy != __rhs.isppy)
        {
            return false;
        }
        return true;
    }

    bool operator<(const ISPinfo& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(ispname < __rhs.ispname)
        {
            return true;
        }
        else if(__rhs.ispname < ispname)
        {
            return false;
        }
        if(isppy < __rhs.isppy)
        {
            return true;
        }
        else if(__rhs.isppy < isppy)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const ISPinfo& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const ISPinfo& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const ISPinfo& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const ISPinfo& __rhs) const
    {
        return !operator<(__rhs);
    }
};

struct IPinfo
{
    ::std::string startip;
    ::std::string start;
    ::std::string endip;
    ::std::string end;
    ::std::string ipmask;
    ::std::string location;
    ::std::string countryid;
    ::std::string provid;
    ::std::string cityid;
    ::std::string ispid;
    ::std::string opflag;

    bool operator==(const IPinfo& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(startip != __rhs.startip)
        {
            return false;
        }
        if(start != __rhs.start)
        {
            return false;
        }
        if(endip != __rhs.endip)
        {
            return false;
        }
        if(end != __rhs.end)
        {
            return false;
        }
        if(ipmask != __rhs.ipmask)
        {
            return false;
        }
        if(location != __rhs.location)
        {
            return false;
        }
        if(countryid != __rhs.countryid)
        {
            return false;
        }
        if(provid != __rhs.provid)
        {
            return false;
        }
        if(cityid != __rhs.cityid)
        {
            return false;
        }
        if(ispid != __rhs.ispid)
        {
            return false;
        }
        if(opflag != __rhs.opflag)
        {
            return false;
        }
        return true;
    }

    bool operator<(const IPinfo& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(startip < __rhs.startip)
        {
            return true;
        }
        else if(__rhs.startip < startip)
        {
            return false;
        }
        if(start < __rhs.start)
        {
            return true;
        }
        else if(__rhs.start < start)
        {
            return false;
        }
        if(endip < __rhs.endip)
        {
            return true;
        }
        else if(__rhs.endip < endip)
        {
            return false;
        }
        if(end < __rhs.end)
        {
            return true;
        }
        else if(__rhs.end < end)
        {
            return false;
        }
        if(ipmask < __rhs.ipmask)
        {
            return true;
        }
        else if(__rhs.ipmask < ipmask)
        {
            return false;
        }
        if(location < __rhs.location)
        {
            return true;
        }
        else if(__rhs.location < location)
        {
            return false;
        }
        if(countryid < __rhs.countryid)
        {
            return true;
        }
        else if(__rhs.countryid < countryid)
        {
            return false;
        }
        if(provid < __rhs.provid)
        {
            return true;
        }
        else if(__rhs.provid < provid)
        {
            return false;
        }
        if(cityid < __rhs.cityid)
        {
            return true;
        }
        else if(__rhs.cityid < cityid)
        {
            return false;
        }
        if(ispid < __rhs.ispid)
        {
            return true;
        }
        else if(__rhs.ispid < ispid)
        {
            return false;
        }
        if(opflag < __rhs.opflag)
        {
            return true;
        }
        else if(__rhs.opflag < opflag)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const IPinfo& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const IPinfo& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const IPinfo& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const IPinfo& __rhs) const
    {
        return !operator<(__rhs);
    }
};

struct Odie
{
    ::std::string start;
    ::std::string end;
    ::std::string location;
    ::std::string ispname;
    ::std::string countryid;
    ::std::string provid;
    ::std::string cityid;
    ::std::string ispid;

    bool operator==(const Odie& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(start != __rhs.start)
        {
            return false;
        }
        if(end != __rhs.end)
        {
            return false;
        }
        if(location != __rhs.location)
        {
            return false;
        }
        if(ispname != __rhs.ispname)
        {
            return false;
        }
        if(countryid != __rhs.countryid)
        {
            return false;
        }
        if(provid != __rhs.provid)
        {
            return false;
        }
        if(cityid != __rhs.cityid)
        {
            return false;
        }
        if(ispid != __rhs.ispid)
        {
            return false;
        }
        return true;
    }

    bool operator<(const Odie& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(start < __rhs.start)
        {
            return true;
        }
        else if(__rhs.start < start)
        {
            return false;
        }
        if(end < __rhs.end)
        {
            return true;
        }
        else if(__rhs.end < end)
        {
            return false;
        }
        if(location < __rhs.location)
        {
            return true;
        }
        else if(__rhs.location < location)
        {
            return false;
        }
        if(ispname < __rhs.ispname)
        {
            return true;
        }
        else if(__rhs.ispname < ispname)
        {
            return false;
        }
        if(countryid < __rhs.countryid)
        {
            return true;
        }
        else if(__rhs.countryid < countryid)
        {
            return false;
        }
        if(provid < __rhs.provid)
        {
            return true;
        }
        else if(__rhs.provid < provid)
        {
            return false;
        }
        if(cityid < __rhs.cityid)
        {
            return true;
        }
        else if(__rhs.cityid < cityid)
        {
            return false;
        }
        if(ispid < __rhs.ispid)
        {
            return true;
        }
        else if(__rhs.ispid < ispid)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const Odie& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const Odie& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const Odie& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const Odie& __rhs) const
    {
        return !operator<(__rhs);
    }
};

}

namespace jk
{

typedef ::std::vector< ::IPMS::dx::SSIsp> SSIspList;

typedef ::std::vector< ::IPMS::dx::IPhebing> IPhebingList;

typedef ::std::vector< ::IPMS::dx::AREAinfo> AREAinfoList;

typedef ::std::vector< ::IPMS::dx::IPinfo> IPinfoList;

typedef ::std::vector< ::IPMS::dx::SSinfo> SSinfoList;

typedef ::std::vector< ::IPMS::dx::ISPinfo> ISPinfoList;

typedef ::std::vector< ::IPMS::dx::PRinfo> PRinfoList;

typedef ::std::vector< ::IPMS::dx::IPpart> IPpartList;

typedef ::std::vector< ::IPMS::dx::Odie> OdieList;

}

}

namespace Ice
{
template<>
struct StreamableTraits< ::IPMS::yc::IPUploadError>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

template<>
struct StreamableTraits< ::IPMS::yc::IPDataTooLargerError>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

template<>
struct StreamableTraits< ::IPMS::yc::IPDownloadError>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

template<>
struct StreamableTraits< ::IPMS::dx::IPhebing>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 4;
    static const bool fixedLength = false;
};

template<class S>
struct StreamWriter< ::IPMS::dx::IPhebing, S>
{
    static void write(S* __os, const ::IPMS::dx::IPhebing& v)
    {
        __os->write(v.start);
        __os->write(v.end);
        __os->write(v.provid);
        __os->write(v.cityid);
    }
};

template<class S>
struct StreamReader< ::IPMS::dx::IPhebing, S>
{
    static void read(S* __is, ::IPMS::dx::IPhebing& v)
    {
        __is->read(v.start);
        __is->read(v.end);
        __is->read(v.provid);
        __is->read(v.cityid);
    }
};

template<>
struct StreamableTraits< ::IPMS::dx::AREAinfo>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 2;
    static const bool fixedLength = false;
};

template<class S>
struct StreamWriter< ::IPMS::dx::AREAinfo, S>
{
    static void write(S* __os, const ::IPMS::dx::AREAinfo& v)
    {
        __os->write(v.areapy);
        __os->write(v.areaname);
    }
};

template<class S>
struct StreamReader< ::IPMS::dx::AREAinfo, S>
{
    static void read(S* __is, ::IPMS::dx::AREAinfo& v)
    {
        __is->read(v.areapy);
        __is->read(v.areaname);
    }
};

template<>
struct StreamableTraits< ::IPMS::dx::SSIsp>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 3;
    static const bool fixedLength = false;
};

template<class S>
struct StreamWriter< ::IPMS::dx::SSIsp, S>
{
    static void write(S* __os, const ::IPMS::dx::SSIsp& v)
    {
        __os->write(v.shengpy);
        __os->write(v.shipy);
        __os->write(v.isppy);
    }
};

template<class S>
struct StreamReader< ::IPMS::dx::SSIsp, S>
{
    static void read(S* __is, ::IPMS::dx::SSIsp& v)
    {
        __is->read(v.shengpy);
        __is->read(v.shipy);
        __is->read(v.isppy);
    }
};

template<>
struct StreamableTraits< ::IPMS::dx::VIEWinfo>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 10;
    static const bool fixedLength = false;
};

template<class S>
struct StreamWriter< ::IPMS::dx::VIEWinfo, S>
{
    static void write(S* __os, const ::IPMS::dx::VIEWinfo& v)
    {
        __os->write(v.viewname);
        __os->write(v.viewareaid);
        __os->write(v.viewispid);
        __os->write(v.viewpci);
    }
};

template<class S>
struct StreamReader< ::IPMS::dx::VIEWinfo, S>
{
    static void read(S* __is, ::IPMS::dx::VIEWinfo& v)
    {
        __is->read(v.viewname);
        __is->read(v.viewareaid);
        __is->read(v.viewispid);
        __is->read(v.viewpci);
    }
};

template<>
struct StreamableTraits< ::IPMS::dx::IPpart>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 5;
    static const bool fixedLength = false;
};

template<class S>
struct StreamWriter< ::IPMS::dx::IPpart, S>
{
    static void write(S* __os, const ::IPMS::dx::IPpart& v)
    {
        __os->write(v.ipparts);
        __os->write(v.startip);
        __os->write(v.start);
        __os->write(v.end);
        __os->write(v.endip);
    }
};

template<class S>
struct StreamReader< ::IPMS::dx::IPpart, S>
{
    static void read(S* __is, ::IPMS::dx::IPpart& v)
    {
        __is->read(v.ipparts);
        __is->read(v.startip);
        __is->read(v.start);
        __is->read(v.end);
        __is->read(v.endip);
    }
};

template<>
struct StreamableTraits< ::IPMS::dx::PRinfo>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 2;
    static const bool fixedLength = false;
};

template<class S>
struct StreamWriter< ::IPMS::dx::PRinfo, S>
{
    static void write(S* __os, const ::IPMS::dx::PRinfo& v)
    {
        __os->write(v.provname);
        __os->write(v.provpy);
    }
};

template<class S>
struct StreamReader< ::IPMS::dx::PRinfo, S>
{
    static void read(S* __is, ::IPMS::dx::PRinfo& v)
    {
        __is->read(v.provname);
        __is->read(v.provpy);
    }
};

template<>
struct StreamableTraits< ::IPMS::dx::SSinfo>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 4;
    static const bool fixedLength = false;
};

template<class S>
struct StreamWriter< ::IPMS::dx::SSinfo, S>
{
    static void write(S* __os, const ::IPMS::dx::SSinfo& v)
    {
        __os->write(v.provname);
        __os->write(v.provpy);
        __os->write(v.cityname);
        __os->write(v.citypy);
    }
};

template<class S>
struct StreamReader< ::IPMS::dx::SSinfo, S>
{
    static void read(S* __is, ::IPMS::dx::SSinfo& v)
    {
        __is->read(v.provname);
        __is->read(v.provpy);
        __is->read(v.cityname);
        __is->read(v.citypy);
    }
};

template<>
struct StreamableTraits< ::IPMS::dx::ISPinfo>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 2;
    static const bool fixedLength = false;
};

template<class S>
struct StreamWriter< ::IPMS::dx::ISPinfo, S>
{
    static void write(S* __os, const ::IPMS::dx::ISPinfo& v)
    {
        __os->write(v.ispname);
        __os->write(v.isppy);
    }
};

template<class S>
struct StreamReader< ::IPMS::dx::ISPinfo, S>
{
    static void read(S* __is, ::IPMS::dx::ISPinfo& v)
    {
        __is->read(v.ispname);
        __is->read(v.isppy);
    }
};

template<>
struct StreamableTraits< ::IPMS::dx::IPinfo>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 11;
    static const bool fixedLength = false;
};

template<class S>
struct StreamWriter< ::IPMS::dx::IPinfo, S>
{
    static void write(S* __os, const ::IPMS::dx::IPinfo& v)
    {
        __os->write(v.startip);
        __os->write(v.start);
        __os->write(v.endip);
        __os->write(v.end);
        __os->write(v.ipmask);
        __os->write(v.location);
        __os->write(v.countryid);
        __os->write(v.provid);
        __os->write(v.cityid);
        __os->write(v.ispid);
        __os->write(v.opflag);
    }
};

template<class S>
struct StreamReader< ::IPMS::dx::IPinfo, S>
{
    static void read(S* __is, ::IPMS::dx::IPinfo& v)
    {
        __is->read(v.startip);
        __is->read(v.start);
        __is->read(v.endip);
        __is->read(v.end);
        __is->read(v.ipmask);
        __is->read(v.location);
        __is->read(v.countryid);
        __is->read(v.provid);
        __is->read(v.cityid);
        __is->read(v.ispid);
        __is->read(v.opflag);
    }
};

template<>
struct StreamableTraits< ::IPMS::dx::Odie>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 8;
    static const bool fixedLength = false;
};

template<class S>
struct StreamWriter< ::IPMS::dx::Odie, S>
{
    static void write(S* __os, const ::IPMS::dx::Odie& v)
    {
        __os->write(v.start);
        __os->write(v.end);
        __os->write(v.location);
        __os->write(v.ispname);
        __os->write(v.countryid);
        __os->write(v.provid);
        __os->write(v.cityid);
        __os->write(v.ispid);
    }
};

template<class S>
struct StreamReader< ::IPMS::dx::Odie, S>
{
    static void read(S* __is, ::IPMS::dx::Odie& v)
    {
        __is->read(v.start);
        __is->read(v.end);
        __is->read(v.location);
        __is->read(v.ispname);
        __is->read(v.countryid);
        __is->read(v.provid);
        __is->read(v.cityid);
        __is->read(v.ispid);
    }
};

}

namespace IPMS
{

namespace jk
{

class Callback_Ipmstor_ipmssea_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Ipmstor_ipmssea_Base> Callback_Ipmstor_ipmsseaPtr;

class Callback_Ipmstor_updatednipdata_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Ipmstor_updatednipdata_Base> Callback_Ipmstor_updatednipdataPtr;

class Callback_Ipmstor_updatewhois_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Ipmstor_updatewhois_Base> Callback_Ipmstor_updatewhoisPtr;

class Callback_Ipmstor_feedbackview_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Ipmstor_feedbackview_Base> Callback_Ipmstor_feedbackviewPtr;

class Callback_Ipmstor_feedbackqitalianxu_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Ipmstor_feedbackqitalianxu_Base> Callback_Ipmstor_feedbackqitalianxuPtr;

class Callback_Ipmstor_feedbackareaview_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Ipmstor_feedbackareaview_Base> Callback_Ipmstor_feedbackareaviewPtr;

class Callback_Ipmstor_feedbacksp_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Ipmstor_feedbacksp_Base> Callback_Ipmstor_feedbackspPtr;

class Callback_Ipmstor_feedbacks_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Ipmstor_feedbacks_Base> Callback_Ipmstor_feedbacksPtr;

class Callback_Ipmstor_feedbackss_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Ipmstor_feedbackss_Base> Callback_Ipmstor_feedbackssPtr;

class Callback_Ipmstor_feedbackoldss_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Ipmstor_feedbackoldss_Base> Callback_Ipmstor_feedbackoldssPtr;

class Callback_Ipmstor_feedbackhaiwai_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Ipmstor_feedbackhaiwai_Base> Callback_Ipmstor_feedbackhaiwaiPtr;

class Callback_Ipmstor_feedbackisp_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Ipmstor_feedbackisp_Base> Callback_Ipmstor_feedbackispPtr;

class Callback_Ipmstor_feedbackssisp_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Ipmstor_feedbackssisp_Base> Callback_Ipmstor_feedbackssispPtr;

class Callback_Ipmstor_feedbackpushengpy_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Ipmstor_feedbackpushengpy_Base> Callback_Ipmstor_feedbackpushengpyPtr;

class Callback_Ipmstor_updateprovpy_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Ipmstor_updateprovpy_Base> Callback_Ipmstor_updateprovpyPtr;

class Callback_Ipmstor_feedbackarea_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Ipmstor_feedbackarea_Base> Callback_Ipmstor_feedbackareaPtr;

class Callback_Ipmstor_feedbackviewarea_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Ipmstor_feedbackviewarea_Base> Callback_Ipmstor_feedbackviewareaPtr;

class Callback_Ipmstor_feedbackipinfo_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Ipmstor_feedbackipinfo_Base> Callback_Ipmstor_feedbackipinfoPtr;

class Callback_Ipmstor_feedbackviewsheng_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Ipmstor_feedbackviewsheng_Base> Callback_Ipmstor_feedbackviewshengPtr;

class Callback_Ipmstor_feedbackviewlargearea_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Ipmstor_feedbackviewlargearea_Base> Callback_Ipmstor_feedbackviewlargeareaPtr;

class Callback_Ipmstor_updatecitypy_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Ipmstor_updatecitypy_Base> Callback_Ipmstor_updatecitypyPtr;

class Callback_Ipmstor_updatehaiwaipy_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Ipmstor_updatehaiwaipy_Base> Callback_Ipmstor_updatehaiwaipyPtr;

}

}

namespace IceProxy
{

namespace IPMS
{

namespace jk
{

class Ipmstor : virtual public ::IceProxy::Ice::Object
{
public:

    ::std::string ipmssea(const ::std::string& start, const ::std::string& end)
    {
        return ipmssea(start, end, 0);
    }
    ::std::string ipmssea(const ::std::string& start, const ::std::string& end, const ::Ice::Context& __ctx)
    {
        return ipmssea(start, end, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_ipmssea(const ::std::string& start, const ::std::string& end, const ::IceInternal::Function<void (const ::std::string&)>& response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_ipmssea(start, end, 0, response, exception, sent);
    }
    ::Ice::AsyncResultPtr
    begin_ipmssea(const ::std::string& start, const ::std::string& end, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_ipmssea(start, end, 0, ::Ice::newCallback(completed, sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_ipmssea(const ::std::string& start, const ::std::string& end, const ::Ice::Context& ctx, const ::IceInternal::Function<void (const ::std::string&)>& response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_ipmssea(start, end, &ctx, response, exception, sent);
    }
    ::Ice::AsyncResultPtr
    begin_ipmssea(const ::std::string& start, const ::std::string& end, const ::Ice::Context& ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_ipmssea(start, end, &ctx, ::Ice::newCallback(completed, sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_ipmssea(const ::std::string& start, const ::std::string& end, const ::Ice::Context* ctx, const ::IceInternal::Function<void (const ::std::string&)>& response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& exception, const ::IceInternal::Function<void (bool)>& sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::std::string&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::IPMS::jk::IpmstorPrx __proxy = ::IPMS::jk::IpmstorPrx::uncheckedCast(__result->getProxy());
                ::std::string __ret;
                try
                {
                    __ret = __proxy->end_ipmssea(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::std::string&)> _response;
        };
        return begin_ipmssea(start, end, ctx, new Cpp11CB(response, exception, sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_ipmssea(const ::std::string& start, const ::std::string& end)
    {
        return begin_ipmssea(start, end, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_ipmssea(const ::std::string& start, const ::std::string& end, const ::Ice::Context& __ctx)
    {
        return begin_ipmssea(start, end, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_ipmssea(const ::std::string& start, const ::std::string& end, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_ipmssea(start, end, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_ipmssea(const ::std::string& start, const ::std::string& end, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_ipmssea(start, end, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_ipmssea(const ::std::string& start, const ::std::string& end, const ::IPMS::jk::Callback_Ipmstor_ipmsseaPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_ipmssea(start, end, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_ipmssea(const ::std::string& start, const ::std::string& end, const ::Ice::Context& __ctx, const ::IPMS::jk::Callback_Ipmstor_ipmsseaPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_ipmssea(start, end, &__ctx, __del, __cookie);
    }

    ::std::string end_ipmssea(const ::Ice::AsyncResultPtr&);
    
private:

    ::std::string ipmssea(const ::std::string&, const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_ipmssea(const ::std::string&, const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    bool updatednipdata(const ::IPMS::dx::IPinfo& ipinfo)
    {
        return updatednipdata(ipinfo, 0);
    }
    bool updatednipdata(const ::IPMS::dx::IPinfo& ipinfo, const ::Ice::Context& __ctx)
    {
        return updatednipdata(ipinfo, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_updatednipdata(const ::IPMS::dx::IPinfo& ipinfo, const ::IceInternal::Function<void (bool)>& response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_updatednipdata(ipinfo, 0, response, exception, sent);
    }
    ::Ice::AsyncResultPtr
    begin_updatednipdata(const ::IPMS::dx::IPinfo& ipinfo, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_updatednipdata(ipinfo, 0, ::Ice::newCallback(completed, sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_updatednipdata(const ::IPMS::dx::IPinfo& ipinfo, const ::Ice::Context& ctx, const ::IceInternal::Function<void (bool)>& response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_updatednipdata(ipinfo, &ctx, response, exception, sent);
    }
    ::Ice::AsyncResultPtr
    begin_updatednipdata(const ::IPMS::dx::IPinfo& ipinfo, const ::Ice::Context& ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_updatednipdata(ipinfo, &ctx, ::Ice::newCallback(completed, sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_updatednipdata(const ::IPMS::dx::IPinfo& ipinfo, const ::Ice::Context* ctx, const ::IceInternal::Function<void (bool)>& response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& exception, const ::IceInternal::Function<void (bool)>& sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (bool)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::IPMS::jk::IpmstorPrx __proxy = ::IPMS::jk::IpmstorPrx::uncheckedCast(__result->getProxy());
                bool __ret;
                try
                {
                    __ret = __proxy->end_updatednipdata(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (bool)> _response;
        };
        return begin_updatednipdata(ipinfo, ctx, new Cpp11CB(response, exception, sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_updatednipdata(const ::IPMS::dx::IPinfo& ipinfo)
    {
        return begin_updatednipdata(ipinfo, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_updatednipdata(const ::IPMS::dx::IPinfo& ipinfo, const ::Ice::Context& __ctx)
    {
        return begin_updatednipdata(ipinfo, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_updatednipdata(const ::IPMS::dx::IPinfo& ipinfo, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_updatednipdata(ipinfo, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_updatednipdata(const ::IPMS::dx::IPinfo& ipinfo, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_updatednipdata(ipinfo, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_updatednipdata(const ::IPMS::dx::IPinfo& ipinfo, const ::IPMS::jk::Callback_Ipmstor_updatednipdataPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_updatednipdata(ipinfo, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_updatednipdata(const ::IPMS::dx::IPinfo& ipinfo, const ::Ice::Context& __ctx, const ::IPMS::jk::Callback_Ipmstor_updatednipdataPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_updatednipdata(ipinfo, &__ctx, __del, __cookie);
    }

    bool end_updatednipdata(const ::Ice::AsyncResultPtr&);
    
private:

    bool updatednipdata(const ::IPMS::dx::IPinfo&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_updatednipdata(const ::IPMS::dx::IPinfo&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::std::string updatewhois(const ::std::string& ip)
    {
        return updatewhois(ip, 0);
    }
    ::std::string updatewhois(const ::std::string& ip, const ::Ice::Context& __ctx)
    {
        return updatewhois(ip, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_updatewhois(const ::std::string& ip, const ::IceInternal::Function<void (const ::std::string&)>& response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_updatewhois(ip, 0, response, exception, sent);
    }
    ::Ice::AsyncResultPtr
    begin_updatewhois(const ::std::string& ip, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_updatewhois(ip, 0, ::Ice::newCallback(completed, sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_updatewhois(const ::std::string& ip, const ::Ice::Context& ctx, const ::IceInternal::Function<void (const ::std::string&)>& response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_updatewhois(ip, &ctx, response, exception, sent);
    }
    ::Ice::AsyncResultPtr
    begin_updatewhois(const ::std::string& ip, const ::Ice::Context& ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_updatewhois(ip, &ctx, ::Ice::newCallback(completed, sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_updatewhois(const ::std::string& ip, const ::Ice::Context* ctx, const ::IceInternal::Function<void (const ::std::string&)>& response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& exception, const ::IceInternal::Function<void (bool)>& sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::std::string&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::IPMS::jk::IpmstorPrx __proxy = ::IPMS::jk::IpmstorPrx::uncheckedCast(__result->getProxy());
                ::std::string __ret;
                try
                {
                    __ret = __proxy->end_updatewhois(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::std::string&)> _response;
        };
        return begin_updatewhois(ip, ctx, new Cpp11CB(response, exception, sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_updatewhois(const ::std::string& ip)
    {
        return begin_updatewhois(ip, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_updatewhois(const ::std::string& ip, const ::Ice::Context& __ctx)
    {
        return begin_updatewhois(ip, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_updatewhois(const ::std::string& ip, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_updatewhois(ip, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_updatewhois(const ::std::string& ip, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_updatewhois(ip, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_updatewhois(const ::std::string& ip, const ::IPMS::jk::Callback_Ipmstor_updatewhoisPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_updatewhois(ip, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_updatewhois(const ::std::string& ip, const ::Ice::Context& __ctx, const ::IPMS::jk::Callback_Ipmstor_updatewhoisPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_updatewhois(ip, &__ctx, __del, __cookie);
    }

    ::std::string end_updatewhois(const ::Ice::AsyncResultPtr&);
    
private:

    ::std::string updatewhois(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_updatewhois(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::std::string feedbackview(const ::std::string& prov, const ::std::string& city, const ::std::string& isp, const ::std::string& opflag)
    {
        return feedbackview(prov, city, isp, opflag, 0);
    }
    ::std::string feedbackview(const ::std::string& prov, const ::std::string& city, const ::std::string& isp, const ::std::string& opflag, const ::Ice::Context& __ctx)
    {
        return feedbackview(prov, city, isp, opflag, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_feedbackview(const ::std::string& prov, const ::std::string& city, const ::std::string& isp, const ::std::string& opflag, const ::IceInternal::Function<void (const ::std::string&)>& response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_feedbackview(prov, city, isp, opflag, 0, response, exception, sent);
    }
    ::Ice::AsyncResultPtr
    begin_feedbackview(const ::std::string& prov, const ::std::string& city, const ::std::string& isp, const ::std::string& opflag, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_feedbackview(prov, city, isp, opflag, 0, ::Ice::newCallback(completed, sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_feedbackview(const ::std::string& prov, const ::std::string& city, const ::std::string& isp, const ::std::string& opflag, const ::Ice::Context& ctx, const ::IceInternal::Function<void (const ::std::string&)>& response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_feedbackview(prov, city, isp, opflag, &ctx, response, exception, sent);
    }
    ::Ice::AsyncResultPtr
    begin_feedbackview(const ::std::string& prov, const ::std::string& city, const ::std::string& isp, const ::std::string& opflag, const ::Ice::Context& ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_feedbackview(prov, city, isp, opflag, &ctx, ::Ice::newCallback(completed, sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_feedbackview(const ::std::string& prov, const ::std::string& city, const ::std::string& isp, const ::std::string& opflag, const ::Ice::Context* ctx, const ::IceInternal::Function<void (const ::std::string&)>& response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& exception, const ::IceInternal::Function<void (bool)>& sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::std::string&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::IPMS::jk::IpmstorPrx __proxy = ::IPMS::jk::IpmstorPrx::uncheckedCast(__result->getProxy());
                ::std::string __ret;
                try
                {
                    __ret = __proxy->end_feedbackview(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::std::string&)> _response;
        };
        return begin_feedbackview(prov, city, isp, opflag, ctx, new Cpp11CB(response, exception, sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_feedbackview(const ::std::string& prov, const ::std::string& city, const ::std::string& isp, const ::std::string& opflag)
    {
        return begin_feedbackview(prov, city, isp, opflag, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_feedbackview(const ::std::string& prov, const ::std::string& city, const ::std::string& isp, const ::std::string& opflag, const ::Ice::Context& __ctx)
    {
        return begin_feedbackview(prov, city, isp, opflag, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_feedbackview(const ::std::string& prov, const ::std::string& city, const ::std::string& isp, const ::std::string& opflag, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_feedbackview(prov, city, isp, opflag, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_feedbackview(const ::std::string& prov, const ::std::string& city, const ::std::string& isp, const ::std::string& opflag, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_feedbackview(prov, city, isp, opflag, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_feedbackview(const ::std::string& prov, const ::std::string& city, const ::std::string& isp, const ::std::string& opflag, const ::IPMS::jk::Callback_Ipmstor_feedbackviewPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_feedbackview(prov, city, isp, opflag, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_feedbackview(const ::std::string& prov, const ::std::string& city, const ::std::string& isp, const ::std::string& opflag, const ::Ice::Context& __ctx, const ::IPMS::jk::Callback_Ipmstor_feedbackviewPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_feedbackview(prov, city, isp, opflag, &__ctx, __del, __cookie);
    }

    ::std::string end_feedbackview(const ::Ice::AsyncResultPtr&);
    
private:

    ::std::string feedbackview(const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_feedbackview(const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::std::string feedbackqitalianxu(const ::std::string& prov, const ::std::string& city)
    {
        return feedbackqitalianxu(prov, city, 0);
    }
    ::std::string feedbackqitalianxu(const ::std::string& prov, const ::std::string& city, const ::Ice::Context& __ctx)
    {
        return feedbackqitalianxu(prov, city, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_feedbackqitalianxu(const ::std::string& prov, const ::std::string& city, const ::IceInternal::Function<void (const ::std::string&)>& response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_feedbackqitalianxu(prov, city, 0, response, exception, sent);
    }
    ::Ice::AsyncResultPtr
    begin_feedbackqitalianxu(const ::std::string& prov, const ::std::string& city, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_feedbackqitalianxu(prov, city, 0, ::Ice::newCallback(completed, sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_feedbackqitalianxu(const ::std::string& prov, const ::std::string& city, const ::Ice::Context& ctx, const ::IceInternal::Function<void (const ::std::string&)>& response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_feedbackqitalianxu(prov, city, &ctx, response, exception, sent);
    }
    ::Ice::AsyncResultPtr
    begin_feedbackqitalianxu(const ::std::string& prov, const ::std::string& city, const ::Ice::Context& ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_feedbackqitalianxu(prov, city, &ctx, ::Ice::newCallback(completed, sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_feedbackqitalianxu(const ::std::string& prov, const ::std::string& city, const ::Ice::Context* ctx, const ::IceInternal::Function<void (const ::std::string&)>& response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& exception, const ::IceInternal::Function<void (bool)>& sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::std::string&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::IPMS::jk::IpmstorPrx __proxy = ::IPMS::jk::IpmstorPrx::uncheckedCast(__result->getProxy());
                ::std::string __ret;
                try
                {
                    __ret = __proxy->end_feedbackqitalianxu(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::std::string&)> _response;
        };
        return begin_feedbackqitalianxu(prov, city, ctx, new Cpp11CB(response, exception, sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_feedbackqitalianxu(const ::std::string& prov, const ::std::string& city)
    {
        return begin_feedbackqitalianxu(prov, city, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_feedbackqitalianxu(const ::std::string& prov, const ::std::string& city, const ::Ice::Context& __ctx)
    {
        return begin_feedbackqitalianxu(prov, city, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_feedbackqitalianxu(const ::std::string& prov, const ::std::string& city, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_feedbackqitalianxu(prov, city, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_feedbackqitalianxu(const ::std::string& prov, const ::std::string& city, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_feedbackqitalianxu(prov, city, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_feedbackqitalianxu(const ::std::string& prov, const ::std::string& city, const ::IPMS::jk::Callback_Ipmstor_feedbackqitalianxuPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_feedbackqitalianxu(prov, city, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_feedbackqitalianxu(const ::std::string& prov, const ::std::string& city, const ::Ice::Context& __ctx, const ::IPMS::jk::Callback_Ipmstor_feedbackqitalianxuPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_feedbackqitalianxu(prov, city, &__ctx, __del, __cookie);
    }

    ::std::string end_feedbackqitalianxu(const ::Ice::AsyncResultPtr&);
    
private:

    ::std::string feedbackqitalianxu(const ::std::string&, const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_feedbackqitalianxu(const ::std::string&, const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::std::string feedbackareaview(const ::std::string& areapy)
    {
        return feedbackareaview(areapy, 0);
    }
    ::std::string feedbackareaview(const ::std::string& areapy, const ::Ice::Context& __ctx)
    {
        return feedbackareaview(areapy, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_feedbackareaview(const ::std::string& areapy, const ::IceInternal::Function<void (const ::std::string&)>& response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_feedbackareaview(areapy, 0, response, exception, sent);
    }
    ::Ice::AsyncResultPtr
    begin_feedbackareaview(const ::std::string& areapy, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_feedbackareaview(areapy, 0, ::Ice::newCallback(completed, sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_feedbackareaview(const ::std::string& areapy, const ::Ice::Context& ctx, const ::IceInternal::Function<void (const ::std::string&)>& response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_feedbackareaview(areapy, &ctx, response, exception, sent);
    }
    ::Ice::AsyncResultPtr
    begin_feedbackareaview(const ::std::string& areapy, const ::Ice::Context& ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_feedbackareaview(areapy, &ctx, ::Ice::newCallback(completed, sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_feedbackareaview(const ::std::string& areapy, const ::Ice::Context* ctx, const ::IceInternal::Function<void (const ::std::string&)>& response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& exception, const ::IceInternal::Function<void (bool)>& sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::std::string&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::IPMS::jk::IpmstorPrx __proxy = ::IPMS::jk::IpmstorPrx::uncheckedCast(__result->getProxy());
                ::std::string __ret;
                try
                {
                    __ret = __proxy->end_feedbackareaview(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::std::string&)> _response;
        };
        return begin_feedbackareaview(areapy, ctx, new Cpp11CB(response, exception, sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_feedbackareaview(const ::std::string& areapy)
    {
        return begin_feedbackareaview(areapy, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_feedbackareaview(const ::std::string& areapy, const ::Ice::Context& __ctx)
    {
        return begin_feedbackareaview(areapy, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_feedbackareaview(const ::std::string& areapy, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_feedbackareaview(areapy, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_feedbackareaview(const ::std::string& areapy, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_feedbackareaview(areapy, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_feedbackareaview(const ::std::string& areapy, const ::IPMS::jk::Callback_Ipmstor_feedbackareaviewPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_feedbackareaview(areapy, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_feedbackareaview(const ::std::string& areapy, const ::Ice::Context& __ctx, const ::IPMS::jk::Callback_Ipmstor_feedbackareaviewPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_feedbackareaview(areapy, &__ctx, __del, __cookie);
    }

    ::std::string end_feedbackareaview(const ::Ice::AsyncResultPtr&);
    
private:

    ::std::string feedbackareaview(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_feedbackareaview(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::IPMS::jk::PRinfoList feedbacksp()
    {
        return feedbacksp(0);
    }
    ::IPMS::jk::PRinfoList feedbacksp(const ::Ice::Context& __ctx)
    {
        return feedbacksp(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_feedbacksp(const ::IceInternal::Function<void (const ::IPMS::jk::PRinfoList&)>& response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_feedbacksp(0, response, exception, sent);
    }
    ::Ice::AsyncResultPtr
    begin_feedbacksp(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_feedbacksp(0, ::Ice::newCallback(completed, sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_feedbacksp(const ::Ice::Context& ctx, const ::IceInternal::Function<void (const ::IPMS::jk::PRinfoList&)>& response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_feedbacksp(&ctx, response, exception, sent);
    }
    ::Ice::AsyncResultPtr
    begin_feedbacksp(const ::Ice::Context& ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_feedbacksp(&ctx, ::Ice::newCallback(completed, sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_feedbacksp(const ::Ice::Context* ctx, const ::IceInternal::Function<void (const ::IPMS::jk::PRinfoList&)>& response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& exception, const ::IceInternal::Function<void (bool)>& sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::IPMS::jk::PRinfoList&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::IPMS::jk::IpmstorPrx __proxy = ::IPMS::jk::IpmstorPrx::uncheckedCast(__result->getProxy());
                ::IPMS::jk::PRinfoList __ret;
                try
                {
                    __ret = __proxy->end_feedbacksp(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::IPMS::jk::PRinfoList&)> _response;
        };
        return begin_feedbacksp(ctx, new Cpp11CB(response, exception, sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_feedbacksp()
    {
        return begin_feedbacksp(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_feedbacksp(const ::Ice::Context& __ctx)
    {
        return begin_feedbacksp(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_feedbacksp(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_feedbacksp(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_feedbacksp(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_feedbacksp(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_feedbacksp(const ::IPMS::jk::Callback_Ipmstor_feedbackspPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_feedbacksp(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_feedbacksp(const ::Ice::Context& __ctx, const ::IPMS::jk::Callback_Ipmstor_feedbackspPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_feedbacksp(&__ctx, __del, __cookie);
    }

    ::IPMS::jk::PRinfoList end_feedbacksp(const ::Ice::AsyncResultPtr&);
    
private:

    ::IPMS::jk::PRinfoList feedbacksp(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_feedbacksp(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::IPMS::jk::SSinfoList feedbacks()
    {
        return feedbacks(0);
    }
    ::IPMS::jk::SSinfoList feedbacks(const ::Ice::Context& __ctx)
    {
        return feedbacks(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_feedbacks(const ::IceInternal::Function<void (const ::IPMS::jk::SSinfoList&)>& response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_feedbacks(0, response, exception, sent);
    }
    ::Ice::AsyncResultPtr
    begin_feedbacks(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_feedbacks(0, ::Ice::newCallback(completed, sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_feedbacks(const ::Ice::Context& ctx, const ::IceInternal::Function<void (const ::IPMS::jk::SSinfoList&)>& response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_feedbacks(&ctx, response, exception, sent);
    }
    ::Ice::AsyncResultPtr
    begin_feedbacks(const ::Ice::Context& ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_feedbacks(&ctx, ::Ice::newCallback(completed, sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_feedbacks(const ::Ice::Context* ctx, const ::IceInternal::Function<void (const ::IPMS::jk::SSinfoList&)>& response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& exception, const ::IceInternal::Function<void (bool)>& sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::IPMS::jk::SSinfoList&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::IPMS::jk::IpmstorPrx __proxy = ::IPMS::jk::IpmstorPrx::uncheckedCast(__result->getProxy());
                ::IPMS::jk::SSinfoList __ret;
                try
                {
                    __ret = __proxy->end_feedbacks(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::IPMS::jk::SSinfoList&)> _response;
        };
        return begin_feedbacks(ctx, new Cpp11CB(response, exception, sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_feedbacks()
    {
        return begin_feedbacks(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_feedbacks(const ::Ice::Context& __ctx)
    {
        return begin_feedbacks(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_feedbacks(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_feedbacks(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_feedbacks(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_feedbacks(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_feedbacks(const ::IPMS::jk::Callback_Ipmstor_feedbacksPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_feedbacks(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_feedbacks(const ::Ice::Context& __ctx, const ::IPMS::jk::Callback_Ipmstor_feedbacksPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_feedbacks(&__ctx, __del, __cookie);
    }

    ::IPMS::jk::SSinfoList end_feedbacks(const ::Ice::AsyncResultPtr&);
    
private:

    ::IPMS::jk::SSinfoList feedbacks(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_feedbacks(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::IPMS::jk::SSinfoList feedbackss()
    {
        return feedbackss(0);
    }
    ::IPMS::jk::SSinfoList feedbackss(const ::Ice::Context& __ctx)
    {
        return feedbackss(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_feedbackss(const ::IceInternal::Function<void (const ::IPMS::jk::SSinfoList&)>& response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_feedbackss(0, response, exception, sent);
    }
    ::Ice::AsyncResultPtr
    begin_feedbackss(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_feedbackss(0, ::Ice::newCallback(completed, sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_feedbackss(const ::Ice::Context& ctx, const ::IceInternal::Function<void (const ::IPMS::jk::SSinfoList&)>& response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_feedbackss(&ctx, response, exception, sent);
    }
    ::Ice::AsyncResultPtr
    begin_feedbackss(const ::Ice::Context& ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_feedbackss(&ctx, ::Ice::newCallback(completed, sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_feedbackss(const ::Ice::Context* ctx, const ::IceInternal::Function<void (const ::IPMS::jk::SSinfoList&)>& response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& exception, const ::IceInternal::Function<void (bool)>& sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::IPMS::jk::SSinfoList&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::IPMS::jk::IpmstorPrx __proxy = ::IPMS::jk::IpmstorPrx::uncheckedCast(__result->getProxy());
                ::IPMS::jk::SSinfoList __ret;
                try
                {
                    __ret = __proxy->end_feedbackss(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::IPMS::jk::SSinfoList&)> _response;
        };
        return begin_feedbackss(ctx, new Cpp11CB(response, exception, sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_feedbackss()
    {
        return begin_feedbackss(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_feedbackss(const ::Ice::Context& __ctx)
    {
        return begin_feedbackss(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_feedbackss(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_feedbackss(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_feedbackss(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_feedbackss(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_feedbackss(const ::IPMS::jk::Callback_Ipmstor_feedbackssPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_feedbackss(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_feedbackss(const ::Ice::Context& __ctx, const ::IPMS::jk::Callback_Ipmstor_feedbackssPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_feedbackss(&__ctx, __del, __cookie);
    }

    ::IPMS::jk::SSinfoList end_feedbackss(const ::Ice::AsyncResultPtr&);
    
private:

    ::IPMS::jk::SSinfoList feedbackss(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_feedbackss(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::IPMS::jk::SSIspList feedbackoldss()
    {
        return feedbackoldss(0);
    }
    ::IPMS::jk::SSIspList feedbackoldss(const ::Ice::Context& __ctx)
    {
        return feedbackoldss(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_feedbackoldss(const ::IceInternal::Function<void (const ::IPMS::jk::SSIspList&)>& response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_feedbackoldss(0, response, exception, sent);
    }
    ::Ice::AsyncResultPtr
    begin_feedbackoldss(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_feedbackoldss(0, ::Ice::newCallback(completed, sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_feedbackoldss(const ::Ice::Context& ctx, const ::IceInternal::Function<void (const ::IPMS::jk::SSIspList&)>& response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_feedbackoldss(&ctx, response, exception, sent);
    }
    ::Ice::AsyncResultPtr
    begin_feedbackoldss(const ::Ice::Context& ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_feedbackoldss(&ctx, ::Ice::newCallback(completed, sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_feedbackoldss(const ::Ice::Context* ctx, const ::IceInternal::Function<void (const ::IPMS::jk::SSIspList&)>& response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& exception, const ::IceInternal::Function<void (bool)>& sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::IPMS::jk::SSIspList&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::IPMS::jk::IpmstorPrx __proxy = ::IPMS::jk::IpmstorPrx::uncheckedCast(__result->getProxy());
                ::IPMS::jk::SSIspList __ret;
                try
                {
                    __ret = __proxy->end_feedbackoldss(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::IPMS::jk::SSIspList&)> _response;
        };
        return begin_feedbackoldss(ctx, new Cpp11CB(response, exception, sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_feedbackoldss()
    {
        return begin_feedbackoldss(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_feedbackoldss(const ::Ice::Context& __ctx)
    {
        return begin_feedbackoldss(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_feedbackoldss(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_feedbackoldss(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_feedbackoldss(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_feedbackoldss(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_feedbackoldss(const ::IPMS::jk::Callback_Ipmstor_feedbackoldssPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_feedbackoldss(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_feedbackoldss(const ::Ice::Context& __ctx, const ::IPMS::jk::Callback_Ipmstor_feedbackoldssPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_feedbackoldss(&__ctx, __del, __cookie);
    }

    ::IPMS::jk::SSIspList end_feedbackoldss(const ::Ice::AsyncResultPtr&);
    
private:

    ::IPMS::jk::SSIspList feedbackoldss(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_feedbackoldss(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::IPMS::jk::SSinfoList feedbackhaiwai()
    {
        return feedbackhaiwai(0);
    }
    ::IPMS::jk::SSinfoList feedbackhaiwai(const ::Ice::Context& __ctx)
    {
        return feedbackhaiwai(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_feedbackhaiwai(const ::IceInternal::Function<void (const ::IPMS::jk::SSinfoList&)>& response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_feedbackhaiwai(0, response, exception, sent);
    }
    ::Ice::AsyncResultPtr
    begin_feedbackhaiwai(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_feedbackhaiwai(0, ::Ice::newCallback(completed, sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_feedbackhaiwai(const ::Ice::Context& ctx, const ::IceInternal::Function<void (const ::IPMS::jk::SSinfoList&)>& response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_feedbackhaiwai(&ctx, response, exception, sent);
    }
    ::Ice::AsyncResultPtr
    begin_feedbackhaiwai(const ::Ice::Context& ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_feedbackhaiwai(&ctx, ::Ice::newCallback(completed, sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_feedbackhaiwai(const ::Ice::Context* ctx, const ::IceInternal::Function<void (const ::IPMS::jk::SSinfoList&)>& response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& exception, const ::IceInternal::Function<void (bool)>& sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::IPMS::jk::SSinfoList&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::IPMS::jk::IpmstorPrx __proxy = ::IPMS::jk::IpmstorPrx::uncheckedCast(__result->getProxy());
                ::IPMS::jk::SSinfoList __ret;
                try
                {
                    __ret = __proxy->end_feedbackhaiwai(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::IPMS::jk::SSinfoList&)> _response;
        };
        return begin_feedbackhaiwai(ctx, new Cpp11CB(response, exception, sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_feedbackhaiwai()
    {
        return begin_feedbackhaiwai(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_feedbackhaiwai(const ::Ice::Context& __ctx)
    {
        return begin_feedbackhaiwai(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_feedbackhaiwai(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_feedbackhaiwai(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_feedbackhaiwai(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_feedbackhaiwai(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_feedbackhaiwai(const ::IPMS::jk::Callback_Ipmstor_feedbackhaiwaiPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_feedbackhaiwai(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_feedbackhaiwai(const ::Ice::Context& __ctx, const ::IPMS::jk::Callback_Ipmstor_feedbackhaiwaiPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_feedbackhaiwai(&__ctx, __del, __cookie);
    }

    ::IPMS::jk::SSinfoList end_feedbackhaiwai(const ::Ice::AsyncResultPtr&);
    
private:

    ::IPMS::jk::SSinfoList feedbackhaiwai(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_feedbackhaiwai(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::IPMS::jk::ISPinfoList feedbackisp()
    {
        return feedbackisp(0);
    }
    ::IPMS::jk::ISPinfoList feedbackisp(const ::Ice::Context& __ctx)
    {
        return feedbackisp(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_feedbackisp(const ::IceInternal::Function<void (const ::IPMS::jk::ISPinfoList&)>& response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_feedbackisp(0, response, exception, sent);
    }
    ::Ice::AsyncResultPtr
    begin_feedbackisp(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_feedbackisp(0, ::Ice::newCallback(completed, sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_feedbackisp(const ::Ice::Context& ctx, const ::IceInternal::Function<void (const ::IPMS::jk::ISPinfoList&)>& response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_feedbackisp(&ctx, response, exception, sent);
    }
    ::Ice::AsyncResultPtr
    begin_feedbackisp(const ::Ice::Context& ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_feedbackisp(&ctx, ::Ice::newCallback(completed, sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_feedbackisp(const ::Ice::Context* ctx, const ::IceInternal::Function<void (const ::IPMS::jk::ISPinfoList&)>& response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& exception, const ::IceInternal::Function<void (bool)>& sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::IPMS::jk::ISPinfoList&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::IPMS::jk::IpmstorPrx __proxy = ::IPMS::jk::IpmstorPrx::uncheckedCast(__result->getProxy());
                ::IPMS::jk::ISPinfoList __ret;
                try
                {
                    __ret = __proxy->end_feedbackisp(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::IPMS::jk::ISPinfoList&)> _response;
        };
        return begin_feedbackisp(ctx, new Cpp11CB(response, exception, sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_feedbackisp()
    {
        return begin_feedbackisp(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_feedbackisp(const ::Ice::Context& __ctx)
    {
        return begin_feedbackisp(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_feedbackisp(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_feedbackisp(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_feedbackisp(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_feedbackisp(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_feedbackisp(const ::IPMS::jk::Callback_Ipmstor_feedbackispPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_feedbackisp(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_feedbackisp(const ::Ice::Context& __ctx, const ::IPMS::jk::Callback_Ipmstor_feedbackispPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_feedbackisp(&__ctx, __del, __cookie);
    }

    ::IPMS::jk::ISPinfoList end_feedbackisp(const ::Ice::AsyncResultPtr&);
    
private:

    ::IPMS::jk::ISPinfoList feedbackisp(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_feedbackisp(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::IPMS::jk::SSIspList feedbackssisp()
    {
        return feedbackssisp(0);
    }
    ::IPMS::jk::SSIspList feedbackssisp(const ::Ice::Context& __ctx)
    {
        return feedbackssisp(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_feedbackssisp(const ::IceInternal::Function<void (const ::IPMS::jk::SSIspList&)>& response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_feedbackssisp(0, response, exception, sent);
    }
    ::Ice::AsyncResultPtr
    begin_feedbackssisp(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_feedbackssisp(0, ::Ice::newCallback(completed, sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_feedbackssisp(const ::Ice::Context& ctx, const ::IceInternal::Function<void (const ::IPMS::jk::SSIspList&)>& response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_feedbackssisp(&ctx, response, exception, sent);
    }
    ::Ice::AsyncResultPtr
    begin_feedbackssisp(const ::Ice::Context& ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_feedbackssisp(&ctx, ::Ice::newCallback(completed, sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_feedbackssisp(const ::Ice::Context* ctx, const ::IceInternal::Function<void (const ::IPMS::jk::SSIspList&)>& response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& exception, const ::IceInternal::Function<void (bool)>& sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::IPMS::jk::SSIspList&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::IPMS::jk::IpmstorPrx __proxy = ::IPMS::jk::IpmstorPrx::uncheckedCast(__result->getProxy());
                ::IPMS::jk::SSIspList __ret;
                try
                {
                    __ret = __proxy->end_feedbackssisp(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::IPMS::jk::SSIspList&)> _response;
        };
        return begin_feedbackssisp(ctx, new Cpp11CB(response, exception, sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_feedbackssisp()
    {
        return begin_feedbackssisp(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_feedbackssisp(const ::Ice::Context& __ctx)
    {
        return begin_feedbackssisp(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_feedbackssisp(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_feedbackssisp(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_feedbackssisp(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_feedbackssisp(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_feedbackssisp(const ::IPMS::jk::Callback_Ipmstor_feedbackssispPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_feedbackssisp(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_feedbackssisp(const ::Ice::Context& __ctx, const ::IPMS::jk::Callback_Ipmstor_feedbackssispPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_feedbackssisp(&__ctx, __del, __cookie);
    }

    ::IPMS::jk::SSIspList end_feedbackssisp(const ::Ice::AsyncResultPtr&);
    
private:

    ::IPMS::jk::SSIspList feedbackssisp(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_feedbackssisp(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::IPMS::jk::SSinfoList feedbackpushengpy()
    {
        return feedbackpushengpy(0);
    }
    ::IPMS::jk::SSinfoList feedbackpushengpy(const ::Ice::Context& __ctx)
    {
        return feedbackpushengpy(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_feedbackpushengpy(const ::IceInternal::Function<void (const ::IPMS::jk::SSinfoList&)>& response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_feedbackpushengpy(0, response, exception, sent);
    }
    ::Ice::AsyncResultPtr
    begin_feedbackpushengpy(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_feedbackpushengpy(0, ::Ice::newCallback(completed, sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_feedbackpushengpy(const ::Ice::Context& ctx, const ::IceInternal::Function<void (const ::IPMS::jk::SSinfoList&)>& response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_feedbackpushengpy(&ctx, response, exception, sent);
    }
    ::Ice::AsyncResultPtr
    begin_feedbackpushengpy(const ::Ice::Context& ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_feedbackpushengpy(&ctx, ::Ice::newCallback(completed, sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_feedbackpushengpy(const ::Ice::Context* ctx, const ::IceInternal::Function<void (const ::IPMS::jk::SSinfoList&)>& response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& exception, const ::IceInternal::Function<void (bool)>& sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::IPMS::jk::SSinfoList&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::IPMS::jk::IpmstorPrx __proxy = ::IPMS::jk::IpmstorPrx::uncheckedCast(__result->getProxy());
                ::IPMS::jk::SSinfoList __ret;
                try
                {
                    __ret = __proxy->end_feedbackpushengpy(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::IPMS::jk::SSinfoList&)> _response;
        };
        return begin_feedbackpushengpy(ctx, new Cpp11CB(response, exception, sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_feedbackpushengpy()
    {
        return begin_feedbackpushengpy(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_feedbackpushengpy(const ::Ice::Context& __ctx)
    {
        return begin_feedbackpushengpy(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_feedbackpushengpy(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_feedbackpushengpy(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_feedbackpushengpy(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_feedbackpushengpy(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_feedbackpushengpy(const ::IPMS::jk::Callback_Ipmstor_feedbackpushengpyPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_feedbackpushengpy(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_feedbackpushengpy(const ::Ice::Context& __ctx, const ::IPMS::jk::Callback_Ipmstor_feedbackpushengpyPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_feedbackpushengpy(&__ctx, __del, __cookie);
    }

    ::IPMS::jk::SSinfoList end_feedbackpushengpy(const ::Ice::AsyncResultPtr&);
    
private:

    ::IPMS::jk::SSinfoList feedbackpushengpy(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_feedbackpushengpy(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    bool updateprovpy(const ::std::string& provname, const ::std::string& provpy)
    {
        return updateprovpy(provname, provpy, 0);
    }
    bool updateprovpy(const ::std::string& provname, const ::std::string& provpy, const ::Ice::Context& __ctx)
    {
        return updateprovpy(provname, provpy, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_updateprovpy(const ::std::string& provname, const ::std::string& provpy, const ::IceInternal::Function<void (bool)>& response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_updateprovpy(provname, provpy, 0, response, exception, sent);
    }
    ::Ice::AsyncResultPtr
    begin_updateprovpy(const ::std::string& provname, const ::std::string& provpy, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_updateprovpy(provname, provpy, 0, ::Ice::newCallback(completed, sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_updateprovpy(const ::std::string& provname, const ::std::string& provpy, const ::Ice::Context& ctx, const ::IceInternal::Function<void (bool)>& response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_updateprovpy(provname, provpy, &ctx, response, exception, sent);
    }
    ::Ice::AsyncResultPtr
    begin_updateprovpy(const ::std::string& provname, const ::std::string& provpy, const ::Ice::Context& ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_updateprovpy(provname, provpy, &ctx, ::Ice::newCallback(completed, sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_updateprovpy(const ::std::string& provname, const ::std::string& provpy, const ::Ice::Context* ctx, const ::IceInternal::Function<void (bool)>& response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& exception, const ::IceInternal::Function<void (bool)>& sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (bool)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::IPMS::jk::IpmstorPrx __proxy = ::IPMS::jk::IpmstorPrx::uncheckedCast(__result->getProxy());
                bool __ret;
                try
                {
                    __ret = __proxy->end_updateprovpy(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (bool)> _response;
        };
        return begin_updateprovpy(provname, provpy, ctx, new Cpp11CB(response, exception, sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_updateprovpy(const ::std::string& provname, const ::std::string& provpy)
    {
        return begin_updateprovpy(provname, provpy, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_updateprovpy(const ::std::string& provname, const ::std::string& provpy, const ::Ice::Context& __ctx)
    {
        return begin_updateprovpy(provname, provpy, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_updateprovpy(const ::std::string& provname, const ::std::string& provpy, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_updateprovpy(provname, provpy, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_updateprovpy(const ::std::string& provname, const ::std::string& provpy, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_updateprovpy(provname, provpy, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_updateprovpy(const ::std::string& provname, const ::std::string& provpy, const ::IPMS::jk::Callback_Ipmstor_updateprovpyPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_updateprovpy(provname, provpy, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_updateprovpy(const ::std::string& provname, const ::std::string& provpy, const ::Ice::Context& __ctx, const ::IPMS::jk::Callback_Ipmstor_updateprovpyPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_updateprovpy(provname, provpy, &__ctx, __del, __cookie);
    }

    bool end_updateprovpy(const ::Ice::AsyncResultPtr&);
    
private:

    bool updateprovpy(const ::std::string&, const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_updateprovpy(const ::std::string&, const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::IPMS::jk::AREAinfoList feedbackarea()
    {
        return feedbackarea(0);
    }
    ::IPMS::jk::AREAinfoList feedbackarea(const ::Ice::Context& __ctx)
    {
        return feedbackarea(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_feedbackarea(const ::IceInternal::Function<void (const ::IPMS::jk::AREAinfoList&)>& response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_feedbackarea(0, response, exception, sent);
    }
    ::Ice::AsyncResultPtr
    begin_feedbackarea(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_feedbackarea(0, ::Ice::newCallback(completed, sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_feedbackarea(const ::Ice::Context& ctx, const ::IceInternal::Function<void (const ::IPMS::jk::AREAinfoList&)>& response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_feedbackarea(&ctx, response, exception, sent);
    }
    ::Ice::AsyncResultPtr
    begin_feedbackarea(const ::Ice::Context& ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_feedbackarea(&ctx, ::Ice::newCallback(completed, sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_feedbackarea(const ::Ice::Context* ctx, const ::IceInternal::Function<void (const ::IPMS::jk::AREAinfoList&)>& response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& exception, const ::IceInternal::Function<void (bool)>& sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::IPMS::jk::AREAinfoList&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::IPMS::jk::IpmstorPrx __proxy = ::IPMS::jk::IpmstorPrx::uncheckedCast(__result->getProxy());
                ::IPMS::jk::AREAinfoList __ret;
                try
                {
                    __ret = __proxy->end_feedbackarea(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::IPMS::jk::AREAinfoList&)> _response;
        };
        return begin_feedbackarea(ctx, new Cpp11CB(response, exception, sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_feedbackarea()
    {
        return begin_feedbackarea(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_feedbackarea(const ::Ice::Context& __ctx)
    {
        return begin_feedbackarea(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_feedbackarea(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_feedbackarea(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_feedbackarea(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_feedbackarea(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_feedbackarea(const ::IPMS::jk::Callback_Ipmstor_feedbackareaPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_feedbackarea(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_feedbackarea(const ::Ice::Context& __ctx, const ::IPMS::jk::Callback_Ipmstor_feedbackareaPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_feedbackarea(&__ctx, __del, __cookie);
    }

    ::IPMS::jk::AREAinfoList end_feedbackarea(const ::Ice::AsyncResultPtr&);
    
private:

    ::IPMS::jk::AREAinfoList feedbackarea(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_feedbackarea(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::std::string feedbackviewarea(const ::std::string& area)
    {
        return feedbackviewarea(area, 0);
    }
    ::std::string feedbackviewarea(const ::std::string& area, const ::Ice::Context& __ctx)
    {
        return feedbackviewarea(area, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_feedbackviewarea(const ::std::string& area, const ::IceInternal::Function<void (const ::std::string&)>& response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_feedbackviewarea(area, 0, response, exception, sent);
    }
    ::Ice::AsyncResultPtr
    begin_feedbackviewarea(const ::std::string& area, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_feedbackviewarea(area, 0, ::Ice::newCallback(completed, sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_feedbackviewarea(const ::std::string& area, const ::Ice::Context& ctx, const ::IceInternal::Function<void (const ::std::string&)>& response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_feedbackviewarea(area, &ctx, response, exception, sent);
    }
    ::Ice::AsyncResultPtr
    begin_feedbackviewarea(const ::std::string& area, const ::Ice::Context& ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_feedbackviewarea(area, &ctx, ::Ice::newCallback(completed, sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_feedbackviewarea(const ::std::string& area, const ::Ice::Context* ctx, const ::IceInternal::Function<void (const ::std::string&)>& response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& exception, const ::IceInternal::Function<void (bool)>& sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::std::string&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::IPMS::jk::IpmstorPrx __proxy = ::IPMS::jk::IpmstorPrx::uncheckedCast(__result->getProxy());
                ::std::string __ret;
                try
                {
                    __ret = __proxy->end_feedbackviewarea(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::std::string&)> _response;
        };
        return begin_feedbackviewarea(area, ctx, new Cpp11CB(response, exception, sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_feedbackviewarea(const ::std::string& area)
    {
        return begin_feedbackviewarea(area, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_feedbackviewarea(const ::std::string& area, const ::Ice::Context& __ctx)
    {
        return begin_feedbackviewarea(area, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_feedbackviewarea(const ::std::string& area, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_feedbackviewarea(area, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_feedbackviewarea(const ::std::string& area, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_feedbackviewarea(area, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_feedbackviewarea(const ::std::string& area, const ::IPMS::jk::Callback_Ipmstor_feedbackviewareaPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_feedbackviewarea(area, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_feedbackviewarea(const ::std::string& area, const ::Ice::Context& __ctx, const ::IPMS::jk::Callback_Ipmstor_feedbackviewareaPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_feedbackviewarea(area, &__ctx, __del, __cookie);
    }

    ::std::string end_feedbackviewarea(const ::Ice::AsyncResultPtr&);
    
private:

    ::std::string feedbackviewarea(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_feedbackviewarea(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::std::string feedbackipinfo(const ::std::string& ip)
    {
        return feedbackipinfo(ip, 0);
    }
    ::std::string feedbackipinfo(const ::std::string& ip, const ::Ice::Context& __ctx)
    {
        return feedbackipinfo(ip, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_feedbackipinfo(const ::std::string& ip, const ::IceInternal::Function<void (const ::std::string&)>& response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_feedbackipinfo(ip, 0, response, exception, sent);
    }
    ::Ice::AsyncResultPtr
    begin_feedbackipinfo(const ::std::string& ip, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_feedbackipinfo(ip, 0, ::Ice::newCallback(completed, sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_feedbackipinfo(const ::std::string& ip, const ::Ice::Context& ctx, const ::IceInternal::Function<void (const ::std::string&)>& response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_feedbackipinfo(ip, &ctx, response, exception, sent);
    }
    ::Ice::AsyncResultPtr
    begin_feedbackipinfo(const ::std::string& ip, const ::Ice::Context& ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_feedbackipinfo(ip, &ctx, ::Ice::newCallback(completed, sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_feedbackipinfo(const ::std::string& ip, const ::Ice::Context* ctx, const ::IceInternal::Function<void (const ::std::string&)>& response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& exception, const ::IceInternal::Function<void (bool)>& sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::std::string&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::IPMS::jk::IpmstorPrx __proxy = ::IPMS::jk::IpmstorPrx::uncheckedCast(__result->getProxy());
                ::std::string __ret;
                try
                {
                    __ret = __proxy->end_feedbackipinfo(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::std::string&)> _response;
        };
        return begin_feedbackipinfo(ip, ctx, new Cpp11CB(response, exception, sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_feedbackipinfo(const ::std::string& ip)
    {
        return begin_feedbackipinfo(ip, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_feedbackipinfo(const ::std::string& ip, const ::Ice::Context& __ctx)
    {
        return begin_feedbackipinfo(ip, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_feedbackipinfo(const ::std::string& ip, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_feedbackipinfo(ip, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_feedbackipinfo(const ::std::string& ip, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_feedbackipinfo(ip, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_feedbackipinfo(const ::std::string& ip, const ::IPMS::jk::Callback_Ipmstor_feedbackipinfoPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_feedbackipinfo(ip, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_feedbackipinfo(const ::std::string& ip, const ::Ice::Context& __ctx, const ::IPMS::jk::Callback_Ipmstor_feedbackipinfoPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_feedbackipinfo(ip, &__ctx, __del, __cookie);
    }

    ::std::string end_feedbackipinfo(const ::Ice::AsyncResultPtr&);
    
private:

    ::std::string feedbackipinfo(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_feedbackipinfo(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::std::string feedbackviewsheng(const ::std::string& sheng, const ::std::string& isppy)
    {
        return feedbackviewsheng(sheng, isppy, 0);
    }
    ::std::string feedbackviewsheng(const ::std::string& sheng, const ::std::string& isppy, const ::Ice::Context& __ctx)
    {
        return feedbackviewsheng(sheng, isppy, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_feedbackviewsheng(const ::std::string& sheng, const ::std::string& isppy, const ::IceInternal::Function<void (const ::std::string&)>& response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_feedbackviewsheng(sheng, isppy, 0, response, exception, sent);
    }
    ::Ice::AsyncResultPtr
    begin_feedbackviewsheng(const ::std::string& sheng, const ::std::string& isppy, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_feedbackviewsheng(sheng, isppy, 0, ::Ice::newCallback(completed, sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_feedbackviewsheng(const ::std::string& sheng, const ::std::string& isppy, const ::Ice::Context& ctx, const ::IceInternal::Function<void (const ::std::string&)>& response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_feedbackviewsheng(sheng, isppy, &ctx, response, exception, sent);
    }
    ::Ice::AsyncResultPtr
    begin_feedbackviewsheng(const ::std::string& sheng, const ::std::string& isppy, const ::Ice::Context& ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_feedbackviewsheng(sheng, isppy, &ctx, ::Ice::newCallback(completed, sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_feedbackviewsheng(const ::std::string& sheng, const ::std::string& isppy, const ::Ice::Context* ctx, const ::IceInternal::Function<void (const ::std::string&)>& response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& exception, const ::IceInternal::Function<void (bool)>& sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::std::string&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::IPMS::jk::IpmstorPrx __proxy = ::IPMS::jk::IpmstorPrx::uncheckedCast(__result->getProxy());
                ::std::string __ret;
                try
                {
                    __ret = __proxy->end_feedbackviewsheng(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::std::string&)> _response;
        };
        return begin_feedbackviewsheng(sheng, isppy, ctx, new Cpp11CB(response, exception, sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_feedbackviewsheng(const ::std::string& sheng, const ::std::string& isppy)
    {
        return begin_feedbackviewsheng(sheng, isppy, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_feedbackviewsheng(const ::std::string& sheng, const ::std::string& isppy, const ::Ice::Context& __ctx)
    {
        return begin_feedbackviewsheng(sheng, isppy, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_feedbackviewsheng(const ::std::string& sheng, const ::std::string& isppy, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_feedbackviewsheng(sheng, isppy, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_feedbackviewsheng(const ::std::string& sheng, const ::std::string& isppy, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_feedbackviewsheng(sheng, isppy, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_feedbackviewsheng(const ::std::string& sheng, const ::std::string& isppy, const ::IPMS::jk::Callback_Ipmstor_feedbackviewshengPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_feedbackviewsheng(sheng, isppy, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_feedbackviewsheng(const ::std::string& sheng, const ::std::string& isppy, const ::Ice::Context& __ctx, const ::IPMS::jk::Callback_Ipmstor_feedbackviewshengPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_feedbackviewsheng(sheng, isppy, &__ctx, __del, __cookie);
    }

    ::std::string end_feedbackviewsheng(const ::Ice::AsyncResultPtr&);
    
private:

    ::std::string feedbackviewsheng(const ::std::string&, const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_feedbackviewsheng(const ::std::string&, const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::std::string feedbackviewlargearea(const ::std::string& largearea, const ::std::string& isppy)
    {
        return feedbackviewlargearea(largearea, isppy, 0);
    }
    ::std::string feedbackviewlargearea(const ::std::string& largearea, const ::std::string& isppy, const ::Ice::Context& __ctx)
    {
        return feedbackviewlargearea(largearea, isppy, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_feedbackviewlargearea(const ::std::string& largearea, const ::std::string& isppy, const ::IceInternal::Function<void (const ::std::string&)>& response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_feedbackviewlargearea(largearea, isppy, 0, response, exception, sent);
    }
    ::Ice::AsyncResultPtr
    begin_feedbackviewlargearea(const ::std::string& largearea, const ::std::string& isppy, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_feedbackviewlargearea(largearea, isppy, 0, ::Ice::newCallback(completed, sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_feedbackviewlargearea(const ::std::string& largearea, const ::std::string& isppy, const ::Ice::Context& ctx, const ::IceInternal::Function<void (const ::std::string&)>& response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_feedbackviewlargearea(largearea, isppy, &ctx, response, exception, sent);
    }
    ::Ice::AsyncResultPtr
    begin_feedbackviewlargearea(const ::std::string& largearea, const ::std::string& isppy, const ::Ice::Context& ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_feedbackviewlargearea(largearea, isppy, &ctx, ::Ice::newCallback(completed, sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_feedbackviewlargearea(const ::std::string& largearea, const ::std::string& isppy, const ::Ice::Context* ctx, const ::IceInternal::Function<void (const ::std::string&)>& response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& exception, const ::IceInternal::Function<void (bool)>& sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::std::string&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::IPMS::jk::IpmstorPrx __proxy = ::IPMS::jk::IpmstorPrx::uncheckedCast(__result->getProxy());
                ::std::string __ret;
                try
                {
                    __ret = __proxy->end_feedbackviewlargearea(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::std::string&)> _response;
        };
        return begin_feedbackviewlargearea(largearea, isppy, ctx, new Cpp11CB(response, exception, sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_feedbackviewlargearea(const ::std::string& largearea, const ::std::string& isppy)
    {
        return begin_feedbackviewlargearea(largearea, isppy, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_feedbackviewlargearea(const ::std::string& largearea, const ::std::string& isppy, const ::Ice::Context& __ctx)
    {
        return begin_feedbackviewlargearea(largearea, isppy, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_feedbackviewlargearea(const ::std::string& largearea, const ::std::string& isppy, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_feedbackviewlargearea(largearea, isppy, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_feedbackviewlargearea(const ::std::string& largearea, const ::std::string& isppy, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_feedbackviewlargearea(largearea, isppy, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_feedbackviewlargearea(const ::std::string& largearea, const ::std::string& isppy, const ::IPMS::jk::Callback_Ipmstor_feedbackviewlargeareaPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_feedbackviewlargearea(largearea, isppy, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_feedbackviewlargearea(const ::std::string& largearea, const ::std::string& isppy, const ::Ice::Context& __ctx, const ::IPMS::jk::Callback_Ipmstor_feedbackviewlargeareaPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_feedbackviewlargearea(largearea, isppy, &__ctx, __del, __cookie);
    }

    ::std::string end_feedbackviewlargearea(const ::Ice::AsyncResultPtr&);
    
private:

    ::std::string feedbackviewlargearea(const ::std::string&, const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_feedbackviewlargearea(const ::std::string&, const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    bool updatecitypy(const ::std::string& provname, const ::std::string& provpy, const ::std::string& cityname, const ::std::string& citypy)
    {
        return updatecitypy(provname, provpy, cityname, citypy, 0);
    }
    bool updatecitypy(const ::std::string& provname, const ::std::string& provpy, const ::std::string& cityname, const ::std::string& citypy, const ::Ice::Context& __ctx)
    {
        return updatecitypy(provname, provpy, cityname, citypy, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_updatecitypy(const ::std::string& provname, const ::std::string& provpy, const ::std::string& cityname, const ::std::string& citypy, const ::IceInternal::Function<void (bool)>& response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_updatecitypy(provname, provpy, cityname, citypy, 0, response, exception, sent);
    }
    ::Ice::AsyncResultPtr
    begin_updatecitypy(const ::std::string& provname, const ::std::string& provpy, const ::std::string& cityname, const ::std::string& citypy, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_updatecitypy(provname, provpy, cityname, citypy, 0, ::Ice::newCallback(completed, sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_updatecitypy(const ::std::string& provname, const ::std::string& provpy, const ::std::string& cityname, const ::std::string& citypy, const ::Ice::Context& ctx, const ::IceInternal::Function<void (bool)>& response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_updatecitypy(provname, provpy, cityname, citypy, &ctx, response, exception, sent);
    }
    ::Ice::AsyncResultPtr
    begin_updatecitypy(const ::std::string& provname, const ::std::string& provpy, const ::std::string& cityname, const ::std::string& citypy, const ::Ice::Context& ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_updatecitypy(provname, provpy, cityname, citypy, &ctx, ::Ice::newCallback(completed, sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_updatecitypy(const ::std::string& provname, const ::std::string& provpy, const ::std::string& cityname, const ::std::string& citypy, const ::Ice::Context* ctx, const ::IceInternal::Function<void (bool)>& response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& exception, const ::IceInternal::Function<void (bool)>& sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (bool)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::IPMS::jk::IpmstorPrx __proxy = ::IPMS::jk::IpmstorPrx::uncheckedCast(__result->getProxy());
                bool __ret;
                try
                {
                    __ret = __proxy->end_updatecitypy(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (bool)> _response;
        };
        return begin_updatecitypy(provname, provpy, cityname, citypy, ctx, new Cpp11CB(response, exception, sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_updatecitypy(const ::std::string& provname, const ::std::string& provpy, const ::std::string& cityname, const ::std::string& citypy)
    {
        return begin_updatecitypy(provname, provpy, cityname, citypy, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_updatecitypy(const ::std::string& provname, const ::std::string& provpy, const ::std::string& cityname, const ::std::string& citypy, const ::Ice::Context& __ctx)
    {
        return begin_updatecitypy(provname, provpy, cityname, citypy, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_updatecitypy(const ::std::string& provname, const ::std::string& provpy, const ::std::string& cityname, const ::std::string& citypy, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_updatecitypy(provname, provpy, cityname, citypy, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_updatecitypy(const ::std::string& provname, const ::std::string& provpy, const ::std::string& cityname, const ::std::string& citypy, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_updatecitypy(provname, provpy, cityname, citypy, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_updatecitypy(const ::std::string& provname, const ::std::string& provpy, const ::std::string& cityname, const ::std::string& citypy, const ::IPMS::jk::Callback_Ipmstor_updatecitypyPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_updatecitypy(provname, provpy, cityname, citypy, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_updatecitypy(const ::std::string& provname, const ::std::string& provpy, const ::std::string& cityname, const ::std::string& citypy, const ::Ice::Context& __ctx, const ::IPMS::jk::Callback_Ipmstor_updatecitypyPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_updatecitypy(provname, provpy, cityname, citypy, &__ctx, __del, __cookie);
    }

    bool end_updatecitypy(const ::Ice::AsyncResultPtr&);
    
private:

    bool updatecitypy(const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_updatecitypy(const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    bool updatehaiwaipy(const ::std::string& provname, const ::std::string& provpy, const ::std::string& cityname, const ::std::string& citypy)
    {
        return updatehaiwaipy(provname, provpy, cityname, citypy, 0);
    }
    bool updatehaiwaipy(const ::std::string& provname, const ::std::string& provpy, const ::std::string& cityname, const ::std::string& citypy, const ::Ice::Context& __ctx)
    {
        return updatehaiwaipy(provname, provpy, cityname, citypy, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_updatehaiwaipy(const ::std::string& provname, const ::std::string& provpy, const ::std::string& cityname, const ::std::string& citypy, const ::IceInternal::Function<void (bool)>& response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_updatehaiwaipy(provname, provpy, cityname, citypy, 0, response, exception, sent);
    }
    ::Ice::AsyncResultPtr
    begin_updatehaiwaipy(const ::std::string& provname, const ::std::string& provpy, const ::std::string& cityname, const ::std::string& citypy, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_updatehaiwaipy(provname, provpy, cityname, citypy, 0, ::Ice::newCallback(completed, sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_updatehaiwaipy(const ::std::string& provname, const ::std::string& provpy, const ::std::string& cityname, const ::std::string& citypy, const ::Ice::Context& ctx, const ::IceInternal::Function<void (bool)>& response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_updatehaiwaipy(provname, provpy, cityname, citypy, &ctx, response, exception, sent);
    }
    ::Ice::AsyncResultPtr
    begin_updatehaiwaipy(const ::std::string& provname, const ::std::string& provpy, const ::std::string& cityname, const ::std::string& citypy, const ::Ice::Context& ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_updatehaiwaipy(provname, provpy, cityname, citypy, &ctx, ::Ice::newCallback(completed, sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_updatehaiwaipy(const ::std::string& provname, const ::std::string& provpy, const ::std::string& cityname, const ::std::string& citypy, const ::Ice::Context* ctx, const ::IceInternal::Function<void (bool)>& response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& exception, const ::IceInternal::Function<void (bool)>& sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (bool)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::IPMS::jk::IpmstorPrx __proxy = ::IPMS::jk::IpmstorPrx::uncheckedCast(__result->getProxy());
                bool __ret;
                try
                {
                    __ret = __proxy->end_updatehaiwaipy(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (bool)> _response;
        };
        return begin_updatehaiwaipy(provname, provpy, cityname, citypy, ctx, new Cpp11CB(response, exception, sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_updatehaiwaipy(const ::std::string& provname, const ::std::string& provpy, const ::std::string& cityname, const ::std::string& citypy)
    {
        return begin_updatehaiwaipy(provname, provpy, cityname, citypy, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_updatehaiwaipy(const ::std::string& provname, const ::std::string& provpy, const ::std::string& cityname, const ::std::string& citypy, const ::Ice::Context& __ctx)
    {
        return begin_updatehaiwaipy(provname, provpy, cityname, citypy, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_updatehaiwaipy(const ::std::string& provname, const ::std::string& provpy, const ::std::string& cityname, const ::std::string& citypy, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_updatehaiwaipy(provname, provpy, cityname, citypy, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_updatehaiwaipy(const ::std::string& provname, const ::std::string& provpy, const ::std::string& cityname, const ::std::string& citypy, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_updatehaiwaipy(provname, provpy, cityname, citypy, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_updatehaiwaipy(const ::std::string& provname, const ::std::string& provpy, const ::std::string& cityname, const ::std::string& citypy, const ::IPMS::jk::Callback_Ipmstor_updatehaiwaipyPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_updatehaiwaipy(provname, provpy, cityname, citypy, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_updatehaiwaipy(const ::std::string& provname, const ::std::string& provpy, const ::std::string& cityname, const ::std::string& citypy, const ::Ice::Context& __ctx, const ::IPMS::jk::Callback_Ipmstor_updatehaiwaipyPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_updatehaiwaipy(provname, provpy, cityname, citypy, &__ctx, __del, __cookie);
    }

    bool end_updatehaiwaipy(const ::Ice::AsyncResultPtr&);
    
private:

    bool updatehaiwaipy(const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_updatehaiwaipy(const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    
    ::IceInternal::ProxyHandle<Ipmstor> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<Ipmstor*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<Ipmstor> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<Ipmstor*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<Ipmstor> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<Ipmstor*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<Ipmstor> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<Ipmstor*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<Ipmstor> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<Ipmstor*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<Ipmstor> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<Ipmstor*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<Ipmstor> ice_secure(bool __secure) const
    {
        return dynamic_cast<Ipmstor*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<Ipmstor> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<Ipmstor*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<Ipmstor> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<Ipmstor*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<Ipmstor> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<Ipmstor*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<Ipmstor> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<Ipmstor*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<Ipmstor> ice_twoway() const
    {
        return dynamic_cast<Ipmstor*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<Ipmstor> ice_oneway() const
    {
        return dynamic_cast<Ipmstor*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<Ipmstor> ice_batchOneway() const
    {
        return dynamic_cast<Ipmstor*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<Ipmstor> ice_datagram() const
    {
        return dynamic_cast<Ipmstor*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<Ipmstor> ice_batchDatagram() const
    {
        return dynamic_cast<Ipmstor*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<Ipmstor> ice_compress(bool __compress) const
    {
        return dynamic_cast<Ipmstor*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<Ipmstor> ice_timeout(int __timeout) const
    {
        return dynamic_cast<Ipmstor*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<Ipmstor> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<Ipmstor*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<Ipmstor> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<Ipmstor*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

}

}

}

namespace IceDelegate
{

namespace IPMS
{

namespace jk
{

class Ipmstor : virtual public ::IceDelegate::Ice::Object
{
public:

    virtual ::std::string ipmssea(const ::std::string&, const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual bool updatednipdata(const ::IPMS::dx::IPinfo&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::std::string updatewhois(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::std::string feedbackview(const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::std::string feedbackqitalianxu(const ::std::string&, const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::std::string feedbackareaview(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::IPMS::jk::PRinfoList feedbacksp(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::IPMS::jk::SSinfoList feedbacks(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::IPMS::jk::SSinfoList feedbackss(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::IPMS::jk::SSIspList feedbackoldss(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::IPMS::jk::SSinfoList feedbackhaiwai(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::IPMS::jk::ISPinfoList feedbackisp(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::IPMS::jk::SSIspList feedbackssisp(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::IPMS::jk::SSinfoList feedbackpushengpy(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual bool updateprovpy(const ::std::string&, const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::IPMS::jk::AREAinfoList feedbackarea(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::std::string feedbackviewarea(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::std::string feedbackipinfo(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::std::string feedbackviewsheng(const ::std::string&, const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::std::string feedbackviewlargearea(const ::std::string&, const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual bool updatecitypy(const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual bool updatehaiwaipy(const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;
};

}

}

}

namespace IceDelegateM
{

namespace IPMS
{

namespace jk
{

class Ipmstor : virtual public ::IceDelegate::IPMS::jk::Ipmstor,
                virtual public ::IceDelegateM::Ice::Object
{
public:

    virtual ::std::string ipmssea(const ::std::string&, const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual bool updatednipdata(const ::IPMS::dx::IPinfo&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::std::string updatewhois(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::std::string feedbackview(const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::std::string feedbackqitalianxu(const ::std::string&, const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::std::string feedbackareaview(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::IPMS::jk::PRinfoList feedbacksp(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::IPMS::jk::SSinfoList feedbacks(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::IPMS::jk::SSinfoList feedbackss(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::IPMS::jk::SSIspList feedbackoldss(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::IPMS::jk::SSinfoList feedbackhaiwai(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::IPMS::jk::ISPinfoList feedbackisp(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::IPMS::jk::SSIspList feedbackssisp(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::IPMS::jk::SSinfoList feedbackpushengpy(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual bool updateprovpy(const ::std::string&, const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::IPMS::jk::AREAinfoList feedbackarea(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::std::string feedbackviewarea(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::std::string feedbackipinfo(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::std::string feedbackviewsheng(const ::std::string&, const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::std::string feedbackviewlargearea(const ::std::string&, const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual bool updatecitypy(const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual bool updatehaiwaipy(const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);
};

}

}

}

namespace IceDelegateD
{

namespace IPMS
{

namespace jk
{

class Ipmstor : virtual public ::IceDelegate::IPMS::jk::Ipmstor,
                virtual public ::IceDelegateD::Ice::Object
{
public:

    virtual ::std::string ipmssea(const ::std::string&, const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual bool updatednipdata(const ::IPMS::dx::IPinfo&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::std::string updatewhois(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::std::string feedbackview(const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::std::string feedbackqitalianxu(const ::std::string&, const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::std::string feedbackareaview(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::IPMS::jk::PRinfoList feedbacksp(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::IPMS::jk::SSinfoList feedbacks(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::IPMS::jk::SSinfoList feedbackss(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::IPMS::jk::SSIspList feedbackoldss(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::IPMS::jk::SSinfoList feedbackhaiwai(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::IPMS::jk::ISPinfoList feedbackisp(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::IPMS::jk::SSIspList feedbackssisp(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::IPMS::jk::SSinfoList feedbackpushengpy(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual bool updateprovpy(const ::std::string&, const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::IPMS::jk::AREAinfoList feedbackarea(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::std::string feedbackviewarea(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::std::string feedbackipinfo(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::std::string feedbackviewsheng(const ::std::string&, const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::std::string feedbackviewlargearea(const ::std::string&, const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual bool updatecitypy(const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual bool updatehaiwaipy(const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);
};

}

}

}

namespace IPMS
{

namespace jk
{

class Ipmstor : virtual public ::Ice::Object
{
public:

    typedef IpmstorPrx ProxyType;
    typedef IpmstorPtr PointerType;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual ::std::string ipmssea(const ::std::string&, const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___ipmssea(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual bool updatednipdata(const ::IPMS::dx::IPinfo&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___updatednipdata(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::std::string updatewhois(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___updatewhois(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::std::string feedbackview(const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___feedbackview(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::std::string feedbackqitalianxu(const ::std::string&, const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___feedbackqitalianxu(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::std::string feedbackareaview(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___feedbackareaview(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::IPMS::jk::PRinfoList feedbacksp(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___feedbacksp(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::IPMS::jk::SSinfoList feedbacks(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___feedbacks(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::IPMS::jk::SSinfoList feedbackss(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___feedbackss(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::IPMS::jk::SSIspList feedbackoldss(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___feedbackoldss(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::IPMS::jk::SSinfoList feedbackhaiwai(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___feedbackhaiwai(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::IPMS::jk::ISPinfoList feedbackisp(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___feedbackisp(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::IPMS::jk::SSIspList feedbackssisp(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___feedbackssisp(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::IPMS::jk::SSinfoList feedbackpushengpy(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___feedbackpushengpy(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual bool updateprovpy(const ::std::string&, const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___updateprovpy(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::IPMS::jk::AREAinfoList feedbackarea(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___feedbackarea(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::std::string feedbackviewarea(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___feedbackviewarea(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::std::string feedbackipinfo(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___feedbackipinfo(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::std::string feedbackviewsheng(const ::std::string&, const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___feedbackviewsheng(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::std::string feedbackviewlargearea(const ::std::string&, const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___feedbackviewlargearea(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual bool updatecitypy(const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___updatecitypy(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual bool updatehaiwaipy(const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___updatehaiwaipy(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif
};

inline bool operator==(const Ipmstor& l, const Ipmstor& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const Ipmstor& l, const Ipmstor& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

}

}

namespace IPMS
{

namespace jk
{

template<class T>
class CallbackNC_Ipmstor_ipmssea : public Callback_Ipmstor_ipmssea_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_Ipmstor_ipmssea(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::IPMS::jk::IpmstorPrx __proxy = ::IPMS::jk::IpmstorPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_ipmssea(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_Ipmstor_ipmsseaPtr
newCallback_Ipmstor_ipmssea(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Ipmstor_ipmssea<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Ipmstor_ipmsseaPtr
newCallback_Ipmstor_ipmssea(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Ipmstor_ipmssea<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Ipmstor_ipmssea : public Callback_Ipmstor_ipmssea_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_Ipmstor_ipmssea(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::IPMS::jk::IpmstorPrx __proxy = ::IPMS::jk::IpmstorPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_ipmssea(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Ipmstor_ipmsseaPtr
newCallback_Ipmstor_ipmssea(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Ipmstor_ipmssea<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Ipmstor_ipmsseaPtr
newCallback_Ipmstor_ipmssea(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Ipmstor_ipmssea<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Ipmstor_updatednipdata : public Callback_Ipmstor_updatednipdata_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_Ipmstor_updatednipdata(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::IPMS::jk::IpmstorPrx __proxy = ::IPMS::jk::IpmstorPrx::uncheckedCast(__result->getProxy());
        bool __ret;
        try
        {
            __ret = __proxy->end_updatednipdata(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_Ipmstor_updatednipdataPtr
newCallback_Ipmstor_updatednipdata(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Ipmstor_updatednipdata<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Ipmstor_updatednipdataPtr
newCallback_Ipmstor_updatednipdata(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Ipmstor_updatednipdata<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Ipmstor_updatednipdata : public Callback_Ipmstor_updatednipdata_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_Ipmstor_updatednipdata(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::IPMS::jk::IpmstorPrx __proxy = ::IPMS::jk::IpmstorPrx::uncheckedCast(__result->getProxy());
        bool __ret;
        try
        {
            __ret = __proxy->end_updatednipdata(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Ipmstor_updatednipdataPtr
newCallback_Ipmstor_updatednipdata(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Ipmstor_updatednipdata<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Ipmstor_updatednipdataPtr
newCallback_Ipmstor_updatednipdata(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Ipmstor_updatednipdata<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Ipmstor_updatewhois : public Callback_Ipmstor_updatewhois_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_Ipmstor_updatewhois(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::IPMS::jk::IpmstorPrx __proxy = ::IPMS::jk::IpmstorPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_updatewhois(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_Ipmstor_updatewhoisPtr
newCallback_Ipmstor_updatewhois(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Ipmstor_updatewhois<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Ipmstor_updatewhoisPtr
newCallback_Ipmstor_updatewhois(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Ipmstor_updatewhois<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Ipmstor_updatewhois : public Callback_Ipmstor_updatewhois_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_Ipmstor_updatewhois(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::IPMS::jk::IpmstorPrx __proxy = ::IPMS::jk::IpmstorPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_updatewhois(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Ipmstor_updatewhoisPtr
newCallback_Ipmstor_updatewhois(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Ipmstor_updatewhois<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Ipmstor_updatewhoisPtr
newCallback_Ipmstor_updatewhois(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Ipmstor_updatewhois<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Ipmstor_feedbackview : public Callback_Ipmstor_feedbackview_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_Ipmstor_feedbackview(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::IPMS::jk::IpmstorPrx __proxy = ::IPMS::jk::IpmstorPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_feedbackview(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_Ipmstor_feedbackviewPtr
newCallback_Ipmstor_feedbackview(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Ipmstor_feedbackview<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Ipmstor_feedbackviewPtr
newCallback_Ipmstor_feedbackview(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Ipmstor_feedbackview<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Ipmstor_feedbackview : public Callback_Ipmstor_feedbackview_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_Ipmstor_feedbackview(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::IPMS::jk::IpmstorPrx __proxy = ::IPMS::jk::IpmstorPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_feedbackview(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Ipmstor_feedbackviewPtr
newCallback_Ipmstor_feedbackview(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Ipmstor_feedbackview<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Ipmstor_feedbackviewPtr
newCallback_Ipmstor_feedbackview(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Ipmstor_feedbackview<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Ipmstor_feedbackqitalianxu : public Callback_Ipmstor_feedbackqitalianxu_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_Ipmstor_feedbackqitalianxu(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::IPMS::jk::IpmstorPrx __proxy = ::IPMS::jk::IpmstorPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_feedbackqitalianxu(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_Ipmstor_feedbackqitalianxuPtr
newCallback_Ipmstor_feedbackqitalianxu(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Ipmstor_feedbackqitalianxu<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Ipmstor_feedbackqitalianxuPtr
newCallback_Ipmstor_feedbackqitalianxu(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Ipmstor_feedbackqitalianxu<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Ipmstor_feedbackqitalianxu : public Callback_Ipmstor_feedbackqitalianxu_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_Ipmstor_feedbackqitalianxu(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::IPMS::jk::IpmstorPrx __proxy = ::IPMS::jk::IpmstorPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_feedbackqitalianxu(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Ipmstor_feedbackqitalianxuPtr
newCallback_Ipmstor_feedbackqitalianxu(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Ipmstor_feedbackqitalianxu<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Ipmstor_feedbackqitalianxuPtr
newCallback_Ipmstor_feedbackqitalianxu(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Ipmstor_feedbackqitalianxu<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Ipmstor_feedbackareaview : public Callback_Ipmstor_feedbackareaview_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_Ipmstor_feedbackareaview(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::IPMS::jk::IpmstorPrx __proxy = ::IPMS::jk::IpmstorPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_feedbackareaview(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_Ipmstor_feedbackareaviewPtr
newCallback_Ipmstor_feedbackareaview(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Ipmstor_feedbackareaview<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Ipmstor_feedbackareaviewPtr
newCallback_Ipmstor_feedbackareaview(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Ipmstor_feedbackareaview<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Ipmstor_feedbackareaview : public Callback_Ipmstor_feedbackareaview_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_Ipmstor_feedbackareaview(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::IPMS::jk::IpmstorPrx __proxy = ::IPMS::jk::IpmstorPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_feedbackareaview(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Ipmstor_feedbackareaviewPtr
newCallback_Ipmstor_feedbackareaview(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Ipmstor_feedbackareaview<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Ipmstor_feedbackareaviewPtr
newCallback_Ipmstor_feedbackareaview(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Ipmstor_feedbackareaview<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Ipmstor_feedbacksp : public Callback_Ipmstor_feedbacksp_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::IPMS::jk::PRinfoList&);

    CallbackNC_Ipmstor_feedbacksp(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::IPMS::jk::IpmstorPrx __proxy = ::IPMS::jk::IpmstorPrx::uncheckedCast(__result->getProxy());
        ::IPMS::jk::PRinfoList __ret;
        try
        {
            __ret = __proxy->end_feedbacksp(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_Ipmstor_feedbackspPtr
newCallback_Ipmstor_feedbacksp(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::IPMS::jk::PRinfoList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Ipmstor_feedbacksp<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Ipmstor_feedbackspPtr
newCallback_Ipmstor_feedbacksp(T* instance, void (T::*cb)(const ::IPMS::jk::PRinfoList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Ipmstor_feedbacksp<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Ipmstor_feedbacksp : public Callback_Ipmstor_feedbacksp_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::IPMS::jk::PRinfoList&, const CT&);

    Callback_Ipmstor_feedbacksp(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::IPMS::jk::IpmstorPrx __proxy = ::IPMS::jk::IpmstorPrx::uncheckedCast(__result->getProxy());
        ::IPMS::jk::PRinfoList __ret;
        try
        {
            __ret = __proxy->end_feedbacksp(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Ipmstor_feedbackspPtr
newCallback_Ipmstor_feedbacksp(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::IPMS::jk::PRinfoList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Ipmstor_feedbacksp<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Ipmstor_feedbackspPtr
newCallback_Ipmstor_feedbacksp(T* instance, void (T::*cb)(const ::IPMS::jk::PRinfoList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Ipmstor_feedbacksp<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Ipmstor_feedbacks : public Callback_Ipmstor_feedbacks_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::IPMS::jk::SSinfoList&);

    CallbackNC_Ipmstor_feedbacks(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::IPMS::jk::IpmstorPrx __proxy = ::IPMS::jk::IpmstorPrx::uncheckedCast(__result->getProxy());
        ::IPMS::jk::SSinfoList __ret;
        try
        {
            __ret = __proxy->end_feedbacks(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_Ipmstor_feedbacksPtr
newCallback_Ipmstor_feedbacks(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::IPMS::jk::SSinfoList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Ipmstor_feedbacks<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Ipmstor_feedbacksPtr
newCallback_Ipmstor_feedbacks(T* instance, void (T::*cb)(const ::IPMS::jk::SSinfoList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Ipmstor_feedbacks<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Ipmstor_feedbacks : public Callback_Ipmstor_feedbacks_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::IPMS::jk::SSinfoList&, const CT&);

    Callback_Ipmstor_feedbacks(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::IPMS::jk::IpmstorPrx __proxy = ::IPMS::jk::IpmstorPrx::uncheckedCast(__result->getProxy());
        ::IPMS::jk::SSinfoList __ret;
        try
        {
            __ret = __proxy->end_feedbacks(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Ipmstor_feedbacksPtr
newCallback_Ipmstor_feedbacks(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::IPMS::jk::SSinfoList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Ipmstor_feedbacks<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Ipmstor_feedbacksPtr
newCallback_Ipmstor_feedbacks(T* instance, void (T::*cb)(const ::IPMS::jk::SSinfoList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Ipmstor_feedbacks<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Ipmstor_feedbackss : public Callback_Ipmstor_feedbackss_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::IPMS::jk::SSinfoList&);

    CallbackNC_Ipmstor_feedbackss(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::IPMS::jk::IpmstorPrx __proxy = ::IPMS::jk::IpmstorPrx::uncheckedCast(__result->getProxy());
        ::IPMS::jk::SSinfoList __ret;
        try
        {
            __ret = __proxy->end_feedbackss(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_Ipmstor_feedbackssPtr
newCallback_Ipmstor_feedbackss(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::IPMS::jk::SSinfoList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Ipmstor_feedbackss<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Ipmstor_feedbackssPtr
newCallback_Ipmstor_feedbackss(T* instance, void (T::*cb)(const ::IPMS::jk::SSinfoList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Ipmstor_feedbackss<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Ipmstor_feedbackss : public Callback_Ipmstor_feedbackss_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::IPMS::jk::SSinfoList&, const CT&);

    Callback_Ipmstor_feedbackss(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::IPMS::jk::IpmstorPrx __proxy = ::IPMS::jk::IpmstorPrx::uncheckedCast(__result->getProxy());
        ::IPMS::jk::SSinfoList __ret;
        try
        {
            __ret = __proxy->end_feedbackss(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Ipmstor_feedbackssPtr
newCallback_Ipmstor_feedbackss(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::IPMS::jk::SSinfoList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Ipmstor_feedbackss<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Ipmstor_feedbackssPtr
newCallback_Ipmstor_feedbackss(T* instance, void (T::*cb)(const ::IPMS::jk::SSinfoList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Ipmstor_feedbackss<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Ipmstor_feedbackoldss : public Callback_Ipmstor_feedbackoldss_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::IPMS::jk::SSIspList&);

    CallbackNC_Ipmstor_feedbackoldss(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::IPMS::jk::IpmstorPrx __proxy = ::IPMS::jk::IpmstorPrx::uncheckedCast(__result->getProxy());
        ::IPMS::jk::SSIspList __ret;
        try
        {
            __ret = __proxy->end_feedbackoldss(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_Ipmstor_feedbackoldssPtr
newCallback_Ipmstor_feedbackoldss(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::IPMS::jk::SSIspList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Ipmstor_feedbackoldss<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Ipmstor_feedbackoldssPtr
newCallback_Ipmstor_feedbackoldss(T* instance, void (T::*cb)(const ::IPMS::jk::SSIspList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Ipmstor_feedbackoldss<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Ipmstor_feedbackoldss : public Callback_Ipmstor_feedbackoldss_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::IPMS::jk::SSIspList&, const CT&);

    Callback_Ipmstor_feedbackoldss(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::IPMS::jk::IpmstorPrx __proxy = ::IPMS::jk::IpmstorPrx::uncheckedCast(__result->getProxy());
        ::IPMS::jk::SSIspList __ret;
        try
        {
            __ret = __proxy->end_feedbackoldss(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Ipmstor_feedbackoldssPtr
newCallback_Ipmstor_feedbackoldss(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::IPMS::jk::SSIspList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Ipmstor_feedbackoldss<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Ipmstor_feedbackoldssPtr
newCallback_Ipmstor_feedbackoldss(T* instance, void (T::*cb)(const ::IPMS::jk::SSIspList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Ipmstor_feedbackoldss<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Ipmstor_feedbackhaiwai : public Callback_Ipmstor_feedbackhaiwai_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::IPMS::jk::SSinfoList&);

    CallbackNC_Ipmstor_feedbackhaiwai(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::IPMS::jk::IpmstorPrx __proxy = ::IPMS::jk::IpmstorPrx::uncheckedCast(__result->getProxy());
        ::IPMS::jk::SSinfoList __ret;
        try
        {
            __ret = __proxy->end_feedbackhaiwai(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_Ipmstor_feedbackhaiwaiPtr
newCallback_Ipmstor_feedbackhaiwai(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::IPMS::jk::SSinfoList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Ipmstor_feedbackhaiwai<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Ipmstor_feedbackhaiwaiPtr
newCallback_Ipmstor_feedbackhaiwai(T* instance, void (T::*cb)(const ::IPMS::jk::SSinfoList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Ipmstor_feedbackhaiwai<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Ipmstor_feedbackhaiwai : public Callback_Ipmstor_feedbackhaiwai_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::IPMS::jk::SSinfoList&, const CT&);

    Callback_Ipmstor_feedbackhaiwai(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::IPMS::jk::IpmstorPrx __proxy = ::IPMS::jk::IpmstorPrx::uncheckedCast(__result->getProxy());
        ::IPMS::jk::SSinfoList __ret;
        try
        {
            __ret = __proxy->end_feedbackhaiwai(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Ipmstor_feedbackhaiwaiPtr
newCallback_Ipmstor_feedbackhaiwai(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::IPMS::jk::SSinfoList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Ipmstor_feedbackhaiwai<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Ipmstor_feedbackhaiwaiPtr
newCallback_Ipmstor_feedbackhaiwai(T* instance, void (T::*cb)(const ::IPMS::jk::SSinfoList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Ipmstor_feedbackhaiwai<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Ipmstor_feedbackisp : public Callback_Ipmstor_feedbackisp_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::IPMS::jk::ISPinfoList&);

    CallbackNC_Ipmstor_feedbackisp(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::IPMS::jk::IpmstorPrx __proxy = ::IPMS::jk::IpmstorPrx::uncheckedCast(__result->getProxy());
        ::IPMS::jk::ISPinfoList __ret;
        try
        {
            __ret = __proxy->end_feedbackisp(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_Ipmstor_feedbackispPtr
newCallback_Ipmstor_feedbackisp(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::IPMS::jk::ISPinfoList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Ipmstor_feedbackisp<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Ipmstor_feedbackispPtr
newCallback_Ipmstor_feedbackisp(T* instance, void (T::*cb)(const ::IPMS::jk::ISPinfoList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Ipmstor_feedbackisp<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Ipmstor_feedbackisp : public Callback_Ipmstor_feedbackisp_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::IPMS::jk::ISPinfoList&, const CT&);

    Callback_Ipmstor_feedbackisp(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::IPMS::jk::IpmstorPrx __proxy = ::IPMS::jk::IpmstorPrx::uncheckedCast(__result->getProxy());
        ::IPMS::jk::ISPinfoList __ret;
        try
        {
            __ret = __proxy->end_feedbackisp(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Ipmstor_feedbackispPtr
newCallback_Ipmstor_feedbackisp(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::IPMS::jk::ISPinfoList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Ipmstor_feedbackisp<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Ipmstor_feedbackispPtr
newCallback_Ipmstor_feedbackisp(T* instance, void (T::*cb)(const ::IPMS::jk::ISPinfoList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Ipmstor_feedbackisp<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Ipmstor_feedbackssisp : public Callback_Ipmstor_feedbackssisp_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::IPMS::jk::SSIspList&);

    CallbackNC_Ipmstor_feedbackssisp(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::IPMS::jk::IpmstorPrx __proxy = ::IPMS::jk::IpmstorPrx::uncheckedCast(__result->getProxy());
        ::IPMS::jk::SSIspList __ret;
        try
        {
            __ret = __proxy->end_feedbackssisp(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_Ipmstor_feedbackssispPtr
newCallback_Ipmstor_feedbackssisp(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::IPMS::jk::SSIspList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Ipmstor_feedbackssisp<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Ipmstor_feedbackssispPtr
newCallback_Ipmstor_feedbackssisp(T* instance, void (T::*cb)(const ::IPMS::jk::SSIspList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Ipmstor_feedbackssisp<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Ipmstor_feedbackssisp : public Callback_Ipmstor_feedbackssisp_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::IPMS::jk::SSIspList&, const CT&);

    Callback_Ipmstor_feedbackssisp(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::IPMS::jk::IpmstorPrx __proxy = ::IPMS::jk::IpmstorPrx::uncheckedCast(__result->getProxy());
        ::IPMS::jk::SSIspList __ret;
        try
        {
            __ret = __proxy->end_feedbackssisp(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Ipmstor_feedbackssispPtr
newCallback_Ipmstor_feedbackssisp(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::IPMS::jk::SSIspList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Ipmstor_feedbackssisp<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Ipmstor_feedbackssispPtr
newCallback_Ipmstor_feedbackssisp(T* instance, void (T::*cb)(const ::IPMS::jk::SSIspList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Ipmstor_feedbackssisp<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Ipmstor_feedbackpushengpy : public Callback_Ipmstor_feedbackpushengpy_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::IPMS::jk::SSinfoList&);

    CallbackNC_Ipmstor_feedbackpushengpy(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::IPMS::jk::IpmstorPrx __proxy = ::IPMS::jk::IpmstorPrx::uncheckedCast(__result->getProxy());
        ::IPMS::jk::SSinfoList __ret;
        try
        {
            __ret = __proxy->end_feedbackpushengpy(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_Ipmstor_feedbackpushengpyPtr
newCallback_Ipmstor_feedbackpushengpy(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::IPMS::jk::SSinfoList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Ipmstor_feedbackpushengpy<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Ipmstor_feedbackpushengpyPtr
newCallback_Ipmstor_feedbackpushengpy(T* instance, void (T::*cb)(const ::IPMS::jk::SSinfoList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Ipmstor_feedbackpushengpy<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Ipmstor_feedbackpushengpy : public Callback_Ipmstor_feedbackpushengpy_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::IPMS::jk::SSinfoList&, const CT&);

    Callback_Ipmstor_feedbackpushengpy(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::IPMS::jk::IpmstorPrx __proxy = ::IPMS::jk::IpmstorPrx::uncheckedCast(__result->getProxy());
        ::IPMS::jk::SSinfoList __ret;
        try
        {
            __ret = __proxy->end_feedbackpushengpy(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Ipmstor_feedbackpushengpyPtr
newCallback_Ipmstor_feedbackpushengpy(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::IPMS::jk::SSinfoList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Ipmstor_feedbackpushengpy<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Ipmstor_feedbackpushengpyPtr
newCallback_Ipmstor_feedbackpushengpy(T* instance, void (T::*cb)(const ::IPMS::jk::SSinfoList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Ipmstor_feedbackpushengpy<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Ipmstor_updateprovpy : public Callback_Ipmstor_updateprovpy_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_Ipmstor_updateprovpy(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::IPMS::jk::IpmstorPrx __proxy = ::IPMS::jk::IpmstorPrx::uncheckedCast(__result->getProxy());
        bool __ret;
        try
        {
            __ret = __proxy->end_updateprovpy(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_Ipmstor_updateprovpyPtr
newCallback_Ipmstor_updateprovpy(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Ipmstor_updateprovpy<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Ipmstor_updateprovpyPtr
newCallback_Ipmstor_updateprovpy(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Ipmstor_updateprovpy<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Ipmstor_updateprovpy : public Callback_Ipmstor_updateprovpy_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_Ipmstor_updateprovpy(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::IPMS::jk::IpmstorPrx __proxy = ::IPMS::jk::IpmstorPrx::uncheckedCast(__result->getProxy());
        bool __ret;
        try
        {
            __ret = __proxy->end_updateprovpy(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Ipmstor_updateprovpyPtr
newCallback_Ipmstor_updateprovpy(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Ipmstor_updateprovpy<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Ipmstor_updateprovpyPtr
newCallback_Ipmstor_updateprovpy(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Ipmstor_updateprovpy<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Ipmstor_feedbackarea : public Callback_Ipmstor_feedbackarea_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::IPMS::jk::AREAinfoList&);

    CallbackNC_Ipmstor_feedbackarea(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::IPMS::jk::IpmstorPrx __proxy = ::IPMS::jk::IpmstorPrx::uncheckedCast(__result->getProxy());
        ::IPMS::jk::AREAinfoList __ret;
        try
        {
            __ret = __proxy->end_feedbackarea(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_Ipmstor_feedbackareaPtr
newCallback_Ipmstor_feedbackarea(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::IPMS::jk::AREAinfoList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Ipmstor_feedbackarea<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Ipmstor_feedbackareaPtr
newCallback_Ipmstor_feedbackarea(T* instance, void (T::*cb)(const ::IPMS::jk::AREAinfoList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Ipmstor_feedbackarea<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Ipmstor_feedbackarea : public Callback_Ipmstor_feedbackarea_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::IPMS::jk::AREAinfoList&, const CT&);

    Callback_Ipmstor_feedbackarea(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::IPMS::jk::IpmstorPrx __proxy = ::IPMS::jk::IpmstorPrx::uncheckedCast(__result->getProxy());
        ::IPMS::jk::AREAinfoList __ret;
        try
        {
            __ret = __proxy->end_feedbackarea(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Ipmstor_feedbackareaPtr
newCallback_Ipmstor_feedbackarea(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::IPMS::jk::AREAinfoList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Ipmstor_feedbackarea<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Ipmstor_feedbackareaPtr
newCallback_Ipmstor_feedbackarea(T* instance, void (T::*cb)(const ::IPMS::jk::AREAinfoList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Ipmstor_feedbackarea<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Ipmstor_feedbackviewarea : public Callback_Ipmstor_feedbackviewarea_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_Ipmstor_feedbackviewarea(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::IPMS::jk::IpmstorPrx __proxy = ::IPMS::jk::IpmstorPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_feedbackviewarea(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_Ipmstor_feedbackviewareaPtr
newCallback_Ipmstor_feedbackviewarea(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Ipmstor_feedbackviewarea<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Ipmstor_feedbackviewareaPtr
newCallback_Ipmstor_feedbackviewarea(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Ipmstor_feedbackviewarea<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Ipmstor_feedbackviewarea : public Callback_Ipmstor_feedbackviewarea_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_Ipmstor_feedbackviewarea(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::IPMS::jk::IpmstorPrx __proxy = ::IPMS::jk::IpmstorPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_feedbackviewarea(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Ipmstor_feedbackviewareaPtr
newCallback_Ipmstor_feedbackviewarea(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Ipmstor_feedbackviewarea<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Ipmstor_feedbackviewareaPtr
newCallback_Ipmstor_feedbackviewarea(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Ipmstor_feedbackviewarea<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Ipmstor_feedbackipinfo : public Callback_Ipmstor_feedbackipinfo_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_Ipmstor_feedbackipinfo(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::IPMS::jk::IpmstorPrx __proxy = ::IPMS::jk::IpmstorPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_feedbackipinfo(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_Ipmstor_feedbackipinfoPtr
newCallback_Ipmstor_feedbackipinfo(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Ipmstor_feedbackipinfo<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Ipmstor_feedbackipinfoPtr
newCallback_Ipmstor_feedbackipinfo(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Ipmstor_feedbackipinfo<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Ipmstor_feedbackipinfo : public Callback_Ipmstor_feedbackipinfo_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_Ipmstor_feedbackipinfo(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::IPMS::jk::IpmstorPrx __proxy = ::IPMS::jk::IpmstorPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_feedbackipinfo(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Ipmstor_feedbackipinfoPtr
newCallback_Ipmstor_feedbackipinfo(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Ipmstor_feedbackipinfo<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Ipmstor_feedbackipinfoPtr
newCallback_Ipmstor_feedbackipinfo(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Ipmstor_feedbackipinfo<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Ipmstor_feedbackviewsheng : public Callback_Ipmstor_feedbackviewsheng_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_Ipmstor_feedbackviewsheng(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::IPMS::jk::IpmstorPrx __proxy = ::IPMS::jk::IpmstorPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_feedbackviewsheng(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_Ipmstor_feedbackviewshengPtr
newCallback_Ipmstor_feedbackviewsheng(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Ipmstor_feedbackviewsheng<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Ipmstor_feedbackviewshengPtr
newCallback_Ipmstor_feedbackviewsheng(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Ipmstor_feedbackviewsheng<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Ipmstor_feedbackviewsheng : public Callback_Ipmstor_feedbackviewsheng_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_Ipmstor_feedbackviewsheng(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::IPMS::jk::IpmstorPrx __proxy = ::IPMS::jk::IpmstorPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_feedbackviewsheng(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Ipmstor_feedbackviewshengPtr
newCallback_Ipmstor_feedbackviewsheng(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Ipmstor_feedbackviewsheng<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Ipmstor_feedbackviewshengPtr
newCallback_Ipmstor_feedbackviewsheng(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Ipmstor_feedbackviewsheng<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Ipmstor_feedbackviewlargearea : public Callback_Ipmstor_feedbackviewlargearea_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_Ipmstor_feedbackviewlargearea(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::IPMS::jk::IpmstorPrx __proxy = ::IPMS::jk::IpmstorPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_feedbackviewlargearea(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_Ipmstor_feedbackviewlargeareaPtr
newCallback_Ipmstor_feedbackviewlargearea(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Ipmstor_feedbackviewlargearea<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Ipmstor_feedbackviewlargeareaPtr
newCallback_Ipmstor_feedbackviewlargearea(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Ipmstor_feedbackviewlargearea<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Ipmstor_feedbackviewlargearea : public Callback_Ipmstor_feedbackviewlargearea_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_Ipmstor_feedbackviewlargearea(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::IPMS::jk::IpmstorPrx __proxy = ::IPMS::jk::IpmstorPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_feedbackviewlargearea(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Ipmstor_feedbackviewlargeareaPtr
newCallback_Ipmstor_feedbackviewlargearea(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Ipmstor_feedbackviewlargearea<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Ipmstor_feedbackviewlargeareaPtr
newCallback_Ipmstor_feedbackviewlargearea(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Ipmstor_feedbackviewlargearea<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Ipmstor_updatecitypy : public Callback_Ipmstor_updatecitypy_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_Ipmstor_updatecitypy(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::IPMS::jk::IpmstorPrx __proxy = ::IPMS::jk::IpmstorPrx::uncheckedCast(__result->getProxy());
        bool __ret;
        try
        {
            __ret = __proxy->end_updatecitypy(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_Ipmstor_updatecitypyPtr
newCallback_Ipmstor_updatecitypy(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Ipmstor_updatecitypy<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Ipmstor_updatecitypyPtr
newCallback_Ipmstor_updatecitypy(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Ipmstor_updatecitypy<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Ipmstor_updatecitypy : public Callback_Ipmstor_updatecitypy_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_Ipmstor_updatecitypy(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::IPMS::jk::IpmstorPrx __proxy = ::IPMS::jk::IpmstorPrx::uncheckedCast(__result->getProxy());
        bool __ret;
        try
        {
            __ret = __proxy->end_updatecitypy(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Ipmstor_updatecitypyPtr
newCallback_Ipmstor_updatecitypy(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Ipmstor_updatecitypy<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Ipmstor_updatecitypyPtr
newCallback_Ipmstor_updatecitypy(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Ipmstor_updatecitypy<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Ipmstor_updatehaiwaipy : public Callback_Ipmstor_updatehaiwaipy_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_Ipmstor_updatehaiwaipy(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::IPMS::jk::IpmstorPrx __proxy = ::IPMS::jk::IpmstorPrx::uncheckedCast(__result->getProxy());
        bool __ret;
        try
        {
            __ret = __proxy->end_updatehaiwaipy(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_Ipmstor_updatehaiwaipyPtr
newCallback_Ipmstor_updatehaiwaipy(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Ipmstor_updatehaiwaipy<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Ipmstor_updatehaiwaipyPtr
newCallback_Ipmstor_updatehaiwaipy(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Ipmstor_updatehaiwaipy<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Ipmstor_updatehaiwaipy : public Callback_Ipmstor_updatehaiwaipy_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_Ipmstor_updatehaiwaipy(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::IPMS::jk::IpmstorPrx __proxy = ::IPMS::jk::IpmstorPrx::uncheckedCast(__result->getProxy());
        bool __ret;
        try
        {
            __ret = __proxy->end_updatehaiwaipy(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Ipmstor_updatehaiwaipyPtr
newCallback_Ipmstor_updatehaiwaipy(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Ipmstor_updatehaiwaipy<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Ipmstor_updatehaiwaipyPtr
newCallback_Ipmstor_updatehaiwaipy(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Ipmstor_updatehaiwaipy<T, CT>(instance, cb, excb, sentcb);
}

}

}

#endif
